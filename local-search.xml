<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>PyTorch 火速上手</title>
    <link href="/posts/198834cd/"/>
    <url>/posts/198834cd/</url>
    
    <content type="html"><![CDATA[<h2 id="PyTorch-是什么？"><a href="#PyTorch-是什么？" class="headerlink" title="PyTorch 是什么？"></a>PyTorch 是什么？</h2><p>基于 Python 的科学计算包，服务于以下两种场景：</p><ul><li>Numpy 的替代品，可以使用 GPU 的强大计算力</li><li>提供最大的灵活性和高速的深度学习研究平台</li></ul><h2 id="Tensors"><a href="#Tensors" class="headerlink" title="Tensors"></a>Tensors</h2><p>Tensors 与 Numpy 中的 ndarrays 类似，但是在 PyTorch 中 Tensors 可以使用 GPU 进行计算。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function<br><span class="hljs-keyword">import</span> torch<br></code></pre></div></td></tr></table></figure><p>[ 1 ] 创建一个 5x3 的矩阵，但不初始化：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">x = torch.empty(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-comment"># tensor([[0.0000, 0.0000, 0.0000],</span><br><span class="hljs-comment">#         [0.0000, 0.0000, 0.0000],</span><br><span class="hljs-comment">#         [0.0000, 0.0000, 0.0000],</span><br><span class="hljs-comment">#         [0.0000, 0.0000, 0.0000],</span><br><span class="hljs-comment">#         [0.0000, 0.0000, 0.0000]])</span><br></code></pre></div></td></tr></table></figure><p>[ 2 ] 创建一个随机初始化的矩：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">x = torch.rand(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-comment"># tensor([[0.6972, 0.0231, 0.3087],</span><br><span class="hljs-comment">#         [0.2083, 0.6141, 0.6896],</span><br><span class="hljs-comment">#         [0.7228, 0.9715, 0.5304],</span><br><span class="hljs-comment">#         [0.7727, 0.1621, 0.9777],</span><br><span class="hljs-comment">#         [0.6526, 0.6170, 0.2605]])</span><br></code></pre></div></td></tr></table></figure><p>[ 3 ] 创建一个 0 填充的矩阵，数据类型为 long：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">x = torch.zero(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, dtype=torch.long)<br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-comment"># tensor([[0, 0, 0],</span><br><span class="hljs-comment">#         [0, 0, 0],</span><br><span class="hljs-comment">#         [0, 0, 0],</span><br><span class="hljs-comment">#         [0, 0, 0],</span><br><span class="hljs-comment">#         [0, 0, 0]])</span><br></code></pre></div></td></tr></table></figure><p>[ 4 ] 创建一个 tensor 使用现有数据初始化：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">x = torch.tensor(<br>    [<span class="hljs-number">5.5</span>, <span class="hljs-number">3</span>]<br>)<br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-comment"># tensor([5.5000, 3.0000])</span><br></code></pre></div></td></tr></table></figure><p>[ 5 ] 根据现有的 tensor 创建 tensor。这些方法将重用输入 tensor 的属性（如：dtype，除非设置新的值进行覆盖）：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 利用 new_* 方法创建对象</span><br>x = x.new_ones(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, dtype=torch.double)<br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-comment"># tensor([[1., 1., 1.],</span><br><span class="hljs-comment">#         [1., 1., 1.],</span><br><span class="hljs-comment">#         [1., 1., 1.],</span><br><span class="hljs-comment">#         [1., 1., 1.],</span><br><span class="hljs-comment">#         [1., 1., 1.]], dtype=torch.float64)</span><br><br><span class="hljs-comment"># 覆盖 dtype</span><br><span class="hljs-comment"># 对象 size 相同，只是 值和类型 发生变化</span><br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-comment"># tensor([[ 0.5691, -2.0126, -0.4064],</span><br><span class="hljs-comment">#         [-0.0863,  0.4692, -1.1209],</span><br><span class="hljs-comment">#         [-1.1177, -0.5764, -0.5363],</span><br><span class="hljs-comment">#         [-0.4390,  0.6688,  0.0889],</span><br><span class="hljs-comment">#         [ 1.3334, -1.1600,  1.8457]])</span><br></code></pre></div></td></tr></table></figure><p>[ 6 ] 获取 size：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(x.size())<br><span class="hljs-comment"># torch.Size([5, 3])</span><br></code></pre></div></td></tr></table></figure><div class="note note-info">            <p><code>torch.Size</code> 返回 <code>tuple</code> 类型，支持 <code>tuple</code> 类型所有的操作。</p>          </div><p>[ 7 ] 操作</p><p>[ 7.1 ] 加法：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">y = torch.rand(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(x+y)<br><span class="hljs-comment"># tensor([[ 0.7808, -1.4388,  0.3151],</span><br><span class="hljs-comment">#         [-0.0076,  1.0716, -0.8465],</span><br><span class="hljs-comment">#         [-0.8175,  0.3625, -0.2005],</span><br><span class="hljs-comment">#         [ 0.2435,  0.8512,  0.7142],</span><br><span class="hljs-comment">#         [ 1.4737, -0.8545,  2.4833]])</span><br><br><span class="hljs-built_in">print</span>(torch.add(x, y))<br><span class="hljs-comment"># tensor([[ 0.7808, -1.4388,  0.3151],</span><br><span class="hljs-comment">#         [-0.0076,  1.0716, -0.8465],</span><br><span class="hljs-comment">#         [-0.8175,  0.3625, -0.2005],</span><br><span class="hljs-comment">#         [ 0.2435,  0.8512,  0.7142],</span><br><span class="hljs-comment">#         [ 1.4737, -0.8545,  2.4833]])</span><br></code></pre></div></td></tr></table></figure><p>提供输出 tensor 作为参数：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">result = torch.empty(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)<br>torch.add(x, y, out=result)<br><span class="hljs-built_in">print</span>(result)<br><span class="hljs-comment"># tensor([[ 0.7808, -1.4388,  0.3151],</span><br><span class="hljs-comment">#         [-0.0076,  1.0716, -0.8465],</span><br><span class="hljs-comment">#         [-0.8175,  0.3625, -0.2005],</span><br><span class="hljs-comment">#         [ 0.2435,  0.8512,  0.7142],</span><br><span class="hljs-comment">#         [ 1.4737, -0.8545,  2.4833]])</span><br></code></pre></div></td></tr></table></figure><p>[ 7.2 ] 替换：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># add x to y</span><br>y.add_(x)<br><span class="hljs-built_in">print</span>(y)<br><span class="hljs-comment"># tensor([[ 0.7808, -1.4388,  0.3151],</span><br><span class="hljs-comment">#         [-0.0076,  1.0716, -0.8465],</span><br><span class="hljs-comment">#         [-0.8175,  0.3625, -0.2005],</span><br><span class="hljs-comment">#         [ 0.2435,  0.8512,  0.7142],</span><br><span class="hljs-comment">#         [ 1.4737, -0.8545,  2.4833]])</span><br></code></pre></div></td></tr></table></figure><div class="note note-info">            <p><code>_</code> 结尾的操作会替换原变量。<br>如：<code>x_copy_(y)</code>，<code>x.t_()</code> 会改变 <code>x</code></p>          </div><p>[ 7.3 ] 使用 Numpy 中索引方式，对 tensor 进行操作：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(x[:, <span class="hljs-number">1</span>])<br><span class="hljs-comment"># tensor([-2.0126,  0.4692, -0.5764,  0.6688, -1.1600])</span><br></code></pre></div></td></tr></table></figure><p>[ 8 ] <code>torch.view</code> 改变 tensor 的维度和大小 （与 Numpy 中 reshape 类似）：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">x = torch.randn(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>)<br>y = x.view(<span class="hljs-number">16</span>)<br>z = x.view(-<span class="hljs-number">1</span>, <span class="hljs-number">8</span>)  <span class="hljs-comment"># -1 从其他维度推断</span><br><br><span class="hljs-built_in">print</span>(x.size(), y.size(), z.size())<br><span class="hljs-comment"># torch.Size([4, 4]) torch.Size([16]) torch.Size([2, 8])</span><br></code></pre></div></td></tr></table></figure><p>[ 9 ] 如果只有一个元素的 tensor，使用 <code>item()</code> 获取 Python 数据类型的数值：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">x = torch.randn(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(x)<br><span class="hljs-built_in">print</span>(x.item())<br><span class="hljs-comment"># tensor([-0.2368])</span><br><span class="hljs-comment"># -0.23680149018764496</span><br></code></pre></div></td></tr></table></figure><h3 id="Numpy-转换"><a href="#Numpy-转换" class="headerlink" title="Numpy 转换"></a>Numpy 转换</h3><p>Torch Tensor 与 Numpy 数组之间进行转换非常轻松。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">a = torch.ones(<span class="hljs-number">5</span>)<br>b = a.numpy()<br><br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># tensor([1., 1., 1., 1., 1.])</span><br><span class="hljs-built_in">print</span>(b)  <span class="hljs-comment"># [1. 1. 1. 1. 1.]</span><br></code></pre></div></td></tr></table></figure><p><strong>Torch Tensor 与 Numpy 数组共享底层内存地址，修改一个会导致另一个的变化。</strong></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">a.add_(<span class="hljs-number">1</span>)<br><br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># tensor([2., 2., 2., 2., 2.])</span><br><span class="hljs-built_in">print</span>(b)  <span class="hljs-comment"># [2. 2. 2. 2. 2.]</span><br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a = np.ones(<span class="hljs-number">5</span>)<br>b = torch.from_numpy(a)<br>np.add(a, <span class="hljs-number">1</span>, out=a)<br><br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># [2. 2. 2. 2. 2.]</span><br><span class="hljs-built_in">print</span>(b)  <span class="hljs-comment"># tensor([2., 2., 2., 2., 2.], dtype=torch.float64)</span><br></code></pre></div></td></tr></table></figure><div class="note note-info">            <p>所有的 Tensor 类型默认都是基于 CPU， CharTensor 类型不支持到 Numpy 的装换。</p>          </div><h3 id="CUDA-张量"><a href="#CUDA-张量" class="headerlink" title="CUDA 张量"></a>CUDA 张量</h3><p>使用 <code>.to()</code> 可以将 Tensor 移动到任何设备中。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">if</span> torch.cuda.is_available():<br>    device = torch.device(<span class="hljs-string">&#x27;cuda&#x27;</span>)  <span class="hljs-comment"># CUDA 设备对象</span><br>    y = torch.ones_like(x, device=device)  <span class="hljs-comment"># 直接从 GPU 创建张量</span><br>    x = x.to(device)<br>    z = x + y<br>    <span class="hljs-built_in">print</span>(z)  <span class="hljs-comment"># tensor([0.7632], device=&#x27;cuda:0&#x27;)</span><br>    <span class="hljs-built_in">print</span>(z.to(<span class="hljs-string">&#x27;cpu&#x27;</span>, torch.double))  <span class="hljs-comment"># tensor([0.7632], dtype=torch.float64)</span><br></code></pre></div></td></tr></table></figure><h2 id="Autograd-自动求导"><a href="#Autograd-自动求导" class="headerlink" title="Autograd 自动求导"></a>Autograd 自动求导</h2><p>autograd 包为 Tensor 上所有的操作提供了自动求导。它是一个运行时定义的框架，这意味着反向传播是根据你的代码来确定如何运行，并且每次迭代可以是不同的。</p><h3 id="正向传播-反向传播"><a href="#正向传播-反向传播" class="headerlink" title="正向传播 反向传播"></a>正向传播 反向传播</h3><p>神经网络（NN）是在某些输入数据上执行嵌套函数的集合。<br>这些函数由参数（权重和偏差组成）定义，参数在 PyTorch 中存储在张量中。</p><p>训练 NN 分为两个步骤：</p><ul><li>正向传播：在正向传播中，NN 对正确的输出进行最佳猜测。它通过每个函数运行输入数据以进行猜测。</li><li>反向传播：在反向传播中，NN 根据其猜测中的误差调整其参数。它通过从输出向后遍历，收集有关参数（梯度）的误差导数并使用梯度下降来优化参数来实现。</li></ul><p>[ 1 ] 我们从 torchvision 加载了经过预训练的 resnet18 模型。创建一个随机数据张量来表示具有 3 个通道的单个图像，高度和宽度为 64，其对应的label初始化为一些随机值。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch, torchvision<br><br>model = torchvision.models.resnet18(pretrained=<span class="hljs-literal">True</span>)<br>data = torch.rand(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">64</span>, <span class="hljs-number">64</span>)<br>labels = torch.rand(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>)<br></code></pre></div></td></tr></table></figure><p>[ 2 ] 接下来，通过模型的每一层运行输入数据进行预测。<strong>正向传播</strong>。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">prediction = model(data)<br></code></pre></div></td></tr></table></figure><p>[ 3 ] 使用模型的预测（predication）和相应的标签（labels）来计算误差（loss）。<br>下一步通过反向传播此误差。我们在 loss tensor 上调用 <code>.backward()</code> 时，开始反向传播。Autograd 会为每个模型参数计算梯度并将其存储在参数 <code>.grad</code> 属性中。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">loss = (prediction - labels).<span class="hljs-built_in">sum</span>()<br>loss.backword()  <span class="hljs-comment"># backword pass</span><br></code></pre></div></td></tr></table></figure><p>[ 4 ] 接下来，我们加载一个优化器（SDG），学习率为 0.01，动量为 0.9。在 optim 中注册模型的所有参数。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">optim = torch.optim.SDG(model.parameters(), lr=<span class="hljs-number">1e-2</span>, momentum=<span class="hljs-number">0.9</span>)<br></code></pre></div></td></tr></table></figure><p>[ 5 ] 最后，调用 <code>.step()</code> 启动梯度下降。优化器通过 <code>.grad</code> 中存储的梯度来调整每个参数。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">optim.step()  <span class="hljs-comment"># gradient descent</span><br></code></pre></div></td></tr></table></figure><h3 id="神经网络的微分"><a href="#神经网络的微分" class="headerlink" title="神经网络的微分"></a>神经网络的微分</h3><p>这一小节，我们将看看 autograd 如何收集梯度。<br>我们在创建 Tensor 时，使用 <code>requires_grad=True</code> 参数，表示将跟踪 Tensor 的所有操作。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br>a = torch.tensor([<span class="hljs-number">2.</span>, <span class="hljs-number">3.</span>], require_grad=<span class="hljs-literal">True</span>)<br>b = torch.tensor([<span class="hljs-number">6.</span>, <span class="hljs-number">4.</span>], require_grad=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 从 tensor a, b 创建另一个 tensor Q</span><br>Q = <span class="hljs-number">3</span>*a**<span class="hljs-number">3</span> - b**<span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>假设 tensor a，b 是神经网络的参数，tensor Q 是误差。在 NN 训练中，我们想要获得相对于参数的误差，即各自对应的偏导：</p><p><img src="https://source.letitout.cloud/blog/articles/deeplearn/1.png" alt="相对于参数的误差"></p><p>当我们在 tensor Q 上调用 <code>.backward()</code> 时，Autograd 将计算这些梯度并将其存储在各个张量的 <code>.grad</code> 属性中。</p><p>我们需要在 <code>Q.backword()</code> 中显式传递 <code>gradient</code> 参数（与 Q 形状相同的张量，表示 Q 相对本身的梯度）。</p><p><img src="https://source.letitout.cloud/blog/articles/deeplearn/2.png" alt="相对本身的梯度"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">external_grad = torch.tensor([<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>])<br>Q.backward(gradient=external_grad)<br><br><span class="hljs-comment"># 最后，梯度记录在 a.grad b.grad 中，查看收集的梯度是否正确</span><br><span class="hljs-built_in">print</span>(<span class="hljs-number">9</span>*a**<span class="hljs-number">2</span> == a.grad)<br><span class="hljs-comment"># tensor([True, True])</span><br><span class="hljs-built_in">print</span>(-<span class="hljs-number">2</span>*b == b.grad)<br><span class="hljs-comment"># tensor([True, True])</span><br></code></pre></div></td></tr></table></figure><p>我们也可以将 Q 聚合为一个标量，然后隐式地向后调用，如：<code>Q.sum().backward()</code>。</p><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>上一节，我们了解到 nn 包依赖 autograd 包来定义模型并求导。下面，我们将了解如何定义一个网络。一个 nn.Module 包含个 layer 和一个 forward(input) 方法，该方法返回 output。</p><p>如下，这是一个对手写数字图像进行分类的卷积神经网络：</p><p><img src="https://source.letitout.cloud/blog/articles/deeplearn/3.png" alt="CNN"></p><p>神经网络的典型训练过程如下：</p><ul><li>定义包含一些可学习的参数（权重）神经网络模型</li><li>在数据集上迭代</li><li>通过神经网络处理输入</li><li>计算损失（输出结果和正确值的差值大小）</li><li>将梯度反向传播回网络的参数</li><li>更新网络的参数（梯度下降）：weight = weight - learning_rate * gradient</li></ul><h3 id="定义网络"><a href="#定义网络" class="headerlink" title="定义网络"></a>定义网络</h3><p>在模型中必须定义 <code>forward()</code>， <code>backword</code>（用来计算梯度）会被 autograd 自动创建。可在 <code>forward()</code> 中使用任何针对 Tensor 的操作。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Net</span>(<span class="hljs-params">nn.Model</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(Net, self).__init__()<br>        <span class="hljs-comment"># 1 input image channel, 6 output channels, 3x3 square convolution</span><br>        <span class="hljs-comment"># kernel</span><br>        self.conv_1 = nn.Conv2d(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>)<br>        self.conv_2 = nn.Conv2d(<span class="hljs-number">6</span>, <span class="hljs-number">16</span>, <span class="hljs-number">3</span>)<br>        <span class="hljs-comment"># an affine operation: y = Wx + b</span><br>        self.fc1 = nn.Linear(<span class="hljs-number">16</span> * <span class="hljs-number">6</span> *<span class="hljs-number">6</span>, <span class="hljs-number">120</span>)<br>        self.fc2 = nn.Linear(<span class="hljs-number">120</span>, <span class="hljs-number">84</span>)<br>        self.fc3 = nn.Linear(<span class="hljs-number">84</span>, <span class="hljs-number">10</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        <span class="hljs-comment"># Max Pooling over a (2, 2) window</span><br>        x = F.max_pool2d(F.relu(self.conv1(x)), (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>))<br>        <span class="hljs-comment"># If the size is a square you can only specify a single number</span><br>        x = F.max_pool2d(F.relu(self.conv2(x)), <span class="hljs-number">2</span>)<br>        x = x.view(-<span class="hljs-number">1</span>, self.num_flat_features(x))<br>        x = F.relu(self.fc1(x))<br>        x = F.relu(self.fc2(x))<br>        x = self.fc3(x)<br>        <span class="hljs-keyword">return</span> x<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">num_flat_features</span>(<span class="hljs-params">sefl, x</span>):</span><br>        size = x.size()[<span class="hljs-number">1</span>: ]  <span class="hljs-comment"># all dimensions except the batch dimension</span><br>        num_features = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> size:<br>            num_features *= s<br>        <span class="hljs-keyword">return</span> num_features<br><br><br>net = Net()<br><span class="hljs-built_in">print</span>(net)<br><span class="hljs-comment"># Net(</span><br><span class="hljs-comment">#   (conv1): Conv2d(1, 6, kernel_size=(3, 3), stride=(1, 1))</span><br><span class="hljs-comment">#   (conv2): Conv2d(6, 16, kernel_size=(3, 3), stride=(1, 1))</span><br><span class="hljs-comment">#   (fc1): Linear(in_features=576, out_features=120, bias=True)</span><br><span class="hljs-comment">#   (fc2): Linear(in_features=120, out_features=84, bias=True)</span><br><span class="hljs-comment">#   (fc3): Linear(in_features=84, out_features=10, bias=True)</span><br><span class="hljs-comment"># )</span><br></code></pre></div></td></tr></table></figure><p><code>parameters()</code> 返回可被学习的参数（权重）列表和值</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">params = <span class="hljs-built_in">list</span>(net.parameters())<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(params))  <span class="hljs-comment"># 10</span><br><span class="hljs-built_in">print</span>(params[<span class="hljs-number">0</span>].size())  <span class="hljs-comment"># conv1 的 weight  torch.Size([6, 1, 3, 3])</span><br></code></pre></div></td></tr></table></figure><p>测试随机输入 32x32。注：这个网络（LeNet）的期望的输入大小是 32x32，如果使用 MINIST 数据集来训练这个网络，请把图片大小重新调整到 32x32。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-built_in">input</span> = torch.randn(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>)<br>out = net(<span class="hljs-built_in">input</span>)<br><span class="hljs-built_in">print</span>(out)<br><span class="hljs-comment"># tensor([[ 0.1120,  0.0713,  0.1014, -0.0696, -0.1210,  0.0084, -0.0206,  0.1366,</span><br><span class="hljs-comment">#          -0.0455, -0.0036]], grad_fn=&lt;AddmmBackward&gt;)</span><br></code></pre></div></td></tr></table></figure><p>将所有的参数的梯度缓存清零，进行随机梯度的反向传播。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">net.zero_grad()<br>out.backward(torch.randn(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>))<br></code></pre></div></td></tr></table></figure><div class="note note-info">            <p><code>torch.nn</code> 仅支持小批量输入。整个 <code>torch.nn</code> 包都只支持小批量样本，而不支持单个样本。<br>如：<code>nn.Conv2d</code>接受一个4维 Tensor，分别维 sSamples * nChannels * Height * Width （样本数* 通道数 * 高 * 宽）。如果你有单个样本，只需要使用 <code>input.unsqueeze(0)</code> 来添加其他的维数。</p>          </div><p>至此，我们大致了解了如何构建一个网络，回顾一下到目前为止使用到的类。</p><ul><li><p><code>torch.Tensor</code>： 一个多维数组。 支持使用 backward() 进行自动梯度计算，并保存关于这个向量的梯度 w.r.t.</p></li><li><p><code>nn.Model</code>： 神经网络模块。实现封装参数、移动到 GPU 上运行、导出、加载等。</p></li><li><p><code>nn.Parameter</code>： 一种张量。将其分配为 Model 的属性时，自动注册为参数。</p></li><li><p><code>autograd.Function</code>： 实现一个自动求导操作的前向和反向定义。每个 Tensor 操作都会创建至少一个 Function 节点，该节点连接到创建 Tensor 的函数，并编码其历史记录。</p></li></ul><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">output = net(<span class="hljs-built_in">input</span>)<br>target = torch.randn(<span class="hljs-number">10</span>)  <span class="hljs-comment"># 例子：一个假设的结果</span><br>target = target.view(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>)  <span class="hljs-comment"># 让 target 与 output 的形状相同</span><br><br>criterion = nn.MSELoss()<br><br>loss = criterion(output, target)<br><br><span class="hljs-built_in">print</span>(loss)<br></code></pre></div></td></tr></table></figure><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p>要实现反向传播误差，只需要 <code>loss.backward()</code>。<br>但是，需要清除现有的梯度，否则梯度将累积到现有的梯度中。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">net.zero_grad()  <span class="hljs-comment"># 将所有的梯度缓冲归零</span><br><br><span class="hljs-built_in">print</span>(net.conv1.bias.grad)  <span class="hljs-comment"># conv1.bias.grad 反向传播前  tensor([0., 0., 0., 0., 0., 0.])</span><br><br>loss.backward()<br><br><span class="hljs-built_in">print</span>(net.conv1.bias.grad)  <span class="hljs-comment"># 反向传播后  tensor([0.0111, -0.0064,  0.0053, -0.0047,  0.0026, -0.0153])</span><br></code></pre></div></td></tr></table></figure><h3 id="更新权重"><a href="#更新权重" class="headerlink" title="更新权重"></a>更新权重</h3><p>在使用 PyTorch 时，可以使用 <code>torch.optim</code> 中提供的方法进行梯度下降。如：SDG，Nesterov-SDG，Adam，RMSprop 等。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><br><span class="hljs-comment"># 创建一个 optimizer</span><br>optimizer = optim.SDG(net.parameters(), lr=<span class="hljs-number">0.01</span>)<br><br><span class="hljs-comment"># 在训练中循环</span><br>optimizer.zero_grad()  <span class="hljs-comment"># 将梯度缓冲区清零</span><br>output = net(<span class="hljs-built_in">input</span>)<br>loss = criterion(output, target)<br>loass.backword()<br>optimizer.step()  <span class="hljs-comment"># 更新</span><br></code></pre></div></td></tr></table></figure><h2 id="训练分类器"><a href="#训练分类器" class="headerlink" title="训练分类器"></a>训练分类器</h2><h3 id="数据从哪里来？"><a href="#数据从哪里来？" class="headerlink" title="数据从哪里来？"></a>数据从哪里来？</h3><p>通常，需要处理图像、文本、音频或视频数据时，可以使用将数据加载到 NumPy 数组中的标准 Python 包，再将该数值转换为 <code>torch.*Tensor</code>。</p><ul><li>处理图像，可以使用 Pillow，OpenCV</li><li>处理音频，可以使用 SciPy，librosa</li><li>处理文本，可基于 Python 或 Cython 的原始加载，或 NLTK 和 SpaCy</li></ul><p>对于图像任务，其中包含了一个 <code>torchvision</code> 的包，含有常见的数据集（Imagenet，CIFAR10，MNIST等）的数据加载器，以及用于图像的数据转换器（torchvision.datasets 和 torch.utils.data.DataLoader）。</p><p>在本示例中，将使用 CIFAR10 数据集。其中包含 10 分类的图像：“飞机”，“汽车”，“鸟”，“猫”，“鹿”，“狗”，“青蛙”，“马”，“船”，“卡车”。图像的尺寸为 3 * 32 * 32，即尺寸为 32 * 32 像素的 3 通道彩色图像。</p><p><img src="https://source.letitout.cloud/blog/articles/deeplearn/4.png" alt="CIFAR-10"></p><p>接下来，作为演示，将按顺序执行以下步骤训练图像分类器：</p><ul><li>使用 <code>torchvision</code> 加载并标准化 CIFAR10 训练和测试数据集</li><li>定义 CNN</li><li>定义损失函数</li><li>根据训练数据训练网络</li><li>在测试数据上测试网络</li></ul><h3 id="加载并标准化-CIFAR10"><a href="#加载并标准化-CIFAR10" class="headerlink" title="加载并标准化 CIFAR10"></a>加载并标准化 CIFAR10</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">import</span> torchvision.transforms <span class="hljs-keyword">as</span> transforms<br></code></pre></div></td></tr></table></figure><p>torchvision 的输出是 [0, 1] 的 PILImage 图像，我们要把它转换为归一化范围为 [-1, 1] 的张量。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">transform = transforms.Compose(<br>    [transforms.ToTensor(), transforms.Normalize((<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>), (<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>))]<br>)<br><br>trainset = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&#x27;./data&#x27;</span>, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">True</span>, transform=transform)<br>trainloader = torch.utils.data.DataLoader(trainset, batch_size=<span class="hljs-number">4</span>, shuffle=<span class="hljs-literal">True</span>, num_workers=<span class="hljs-number">2</span>)<br><br>testset = trochvision.datasets.CIFAR10(root=<span class="hljs-string">&#x27;./data&#x27;</span>, train=<span class="hljs-literal">False</span>, download=<span class="hljs-literal">True</span>, transform=transform)<br>testloader = torch.utils.data.DataLoader(testset, barch_size=<span class="hljs-number">4</span>, shuffle=<span class="hljs-literal">False</span>, num_workers=<span class="hljs-number">2</span>)<br><br>classes = (<span class="hljs-string">&#x27;plane&#x27;</span>, <span class="hljs-string">&#x27;car&#x27;</span>, <span class="hljs-string">&#x27;bird&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;deer&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;frog&#x27;</span>, <span class="hljs-string">&#x27;horse&#x27;</span>, <span class="hljs-string">&#x27;ship&#x27;</span>, <span class="hljs-string">&#x27;truck&#x27;</span>)<br></code></pre></div></td></tr></table></figure><h3 id="定义-CNN"><a href="#定义-CNN" class="headerlink" title="定义 CNN"></a>定义 CNN</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Net</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(Net, self).__init__()<br>        <span class="hljs-comment"># in_channels, out_channels, kernel_size</span><br>        <span class="hljs-comment"># 输入的为 3 通道图像，提取 6 个特征，得到 6 个 feature map，卷积核为一个 5*5 的矩阵</span><br>        self.conv1 = nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>)<br>        self.pool = nn.MaxPool2d(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>        self.conv2 = nn.Conv2d(<span class="hljs-number">6</span>, <span class="hljs-number">16</span>, <span class="hljs-number">5</span>)<br>        <span class="hljs-comment"># 卷积层输出了 16 个 feature map，每个 feature map 是 6*6 的二维数据</span><br>        self.fc1 = nn.Linear(<span class="hljs-number">16</span> * <span class="hljs-number">5</span> * <span class="hljs-number">5</span>, <span class="hljs-number">120</span>)<br>        self.fc2 = nn.Linear(<span class="hljs-number">120</span>, <span class="hljs-number">84</span>)<br>        self.fc3(<span class="hljs-number">84</span>, <span class="hljs-number">10</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        x = self.pool(F.relu(self.conv1(x)))<br>        x = self.pool(F.relu(self.conv2(x)))<br>        x = x.view(-<span class="hljs-number">1</span>, <span class="hljs-number">16</span> * <span class="hljs-number">5</span> * <span class="hljs-number">5</span>)<br>        x = F.relu(self.fc1(x))<br>        x = F.relu(self.fc2(x))<br>        x = self.fc3(x)<br>        <span class="hljs-keyword">return</span> x<br><br><br>net = Net(s)<br></code></pre></div></td></tr></table></figure><h3 id="定义损失函数和优化器"><a href="#定义损失函数和优化器" class="headerlink" title="定义损失函数和优化器"></a>定义损失函数和优化器</h3><p>这里我们使用交叉熵作为损失函数，使用带动量的随机梯度下降。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><br>criterion = nn.CrossEntropyLoss()<br>optimizer = optim.SDG(net.parameters(), lr=<span class="hljs-number">0.001</span>, momentum=<span class="hljs-number">0.9</span>)<br></code></pre></div></td></tr></table></figure><h3 id="训练网络"><a href="#训练网络" class="headerlink" title="训练网络"></a>训练网络</h3><p>接下来，只需要在迭代数据，将数据输入网络中并优化。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br><br>    running_loss = <span class="hljs-number">0.0</span><br>    <span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(trainloader, <span class="hljs-number">0</span>):<br>        inputs, labels = data  <span class="hljs-comment"># 获取输入</span><br><br>        optimizer.zero_grad()  <span class="hljs-comment"># 将梯度缓冲区清零</span><br><br>        outputs = net(inputs)  <span class="hljs-comment"># 正向传播</span><br>        loss = criterion(outputs, lables)<br>        loss.backward()  <span class="hljs-comment"># 反向传播</span><br>        optimizer.step()  <span class="hljs-comment"># 优化</span><br><br>        running_loss += loss.item()<br>        <span class="hljs-keyword">if</span> i % <span class="hljs-number">2000</span> == <span class="hljs-number">1999</span>:  <span class="hljs-comment"># 每 2000 批次打印一次</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[]&#x27;</span> % (epoch+<span class="hljs-number">1</span>, i+<span class="hljs-number">1</span>, running_loss / <span class="hljs-number">2000</span>))<br>            running_loss = <span class="hljs-number">0.0</span><br></code></pre></div></td></tr></table></figure><h3 id="在测试集上测试数据"><a href="#在测试集上测试数据" class="headerlink" title="在测试集上测试数据"></a>在测试集上测试数据</h3><p>在上面的训练中，我们训练了 2 次，接下来，我们要检测网络是否从数据集中学习到了有用的东西。通过预测神经网络输出的类别标签与实际情况标签对比进行检测。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">corrent = <span class="hljs-number">0</span><br>total = <span class="hljs-number">0</span><br><span class="hljs-keyword">with</span> torch.no_grad():<br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> testloader:<br>        images, lobels = data<br>        outputs = net(images)<br>        _, predicted = torch.<span class="hljs-built_in">max</span>(outputs.data, <span class="hljs-number">1</span>)<br>        total += labels.size(<span class="hljs-number">0</span>)<br>        corrent += (predicted == labels).<span class="hljs-built_in">sum</span>().item()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Accuracy of the network on the 10000 test images: %d %%&#x27;</span> % (<span class="hljs-number">100</span> *corrent / total))<br><span class="hljs-comment"># Accuracy of the network on the 10000 test images: 9%</span><br></code></pre></div></td></tr></table></figure><p>在训练两次的网络中，随机选择的正确率为 10%。网络似乎学到了一些东西。</p><p>那这个网络，识别哪一类好，哪一类不好呢？</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">class_corrent = <span class="hljs-built_in">list</span>(<span class="hljs-number">0.</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br>class_total = <span class="hljs-built_in">list</span>(<span class="hljs-number">0.</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><br><span class="hljs-keyword">with</span> torch.no_grad():<br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> testloader:<br>        images, labels = data<br>        outputs = net(images)<br>        _, predicted = torch.<span class="hljs-built_in">max</span>(outputs, <span class="hljs-number">1</span>)<br>        c = (predicted == labels).squeeze()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>            label = labels[i]<br>            class_correct[label] += c[i].item()<br>            class_total[label] += <span class="hljs-number">1</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Accuracy of %5s : %2d %%&#x27;</span> % (classes[i], <span class="hljs-number">100</span> * class_correct[i] / class_total[i]))<br><br><br><span class="hljs-comment"># Accuracy of plane : 99 %</span><br><span class="hljs-comment"># Accuracy of   car :  0 %</span><br><span class="hljs-comment"># Accuracy of  bird :  0 %</span><br><span class="hljs-comment"># Accuracy of   cat :  0 %</span><br><span class="hljs-comment"># Accuracy of  deer :  0 %</span><br><span class="hljs-comment"># Accuracy of   dog :  0 %</span><br><span class="hljs-comment"># Accuracy of  frog :  0 %</span><br><span class="hljs-comment"># Accuracy of horse :  0 %</span><br><span class="hljs-comment"># Accuracy of  ship :  0 %</span><br><span class="hljs-comment"># Accuracy of truck :  0 %</span><br></code></pre></div></td></tr></table></figure><h2 id="使用-GPU"><a href="#使用-GPU" class="headerlink" title="使用 GPU"></a>使用 GPU</h2><p>与将 tensor 移到 GPU 上一样，神经网络也可以移动到 GPU 上。<br>如果可以使用 CUDA，将设备定义为第一个 cuda 设备：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">device = torch.device(<span class="hljs-string">&#x27;cuda:0&#x27;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;cpu&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(device)<br><span class="hljs-comment"># cuda:0</span><br></code></pre></div></td></tr></table></figure><p>复制 nn 和 tensor 到 GPU 上。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">model = net.to(device)<br><br>inputs, labels = data[<span class="hljs-number">0</span>].to(device), data[<span class="hljs-number">1</span>].to(device)<br></code></pre></div></td></tr></table></figure><div class="note note-info">            <p>使用 <code>.to(device)</code> 并没有复制 nn / tensor 到 GPU 上，而是返回了一个 copy。需要赋值到一个新的变量后在 GPU 上使用这个 nn / tensor。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>PyTorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/3eeb/"/>
    <url>/posts/3eeb/</url>
    
    <content type="html"><![CDATA[<h2 id="Hello"><a href="#Hello" class="headerlink" title="Hello"></a>Hello</h2><p>最近博客重整中。</p><p>文章会慢慢整理放上来。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>线性回归算法</title>
    <link href="/posts/28db4216/"/>
    <url>/posts/28db4216/</url>
    
    <content type="html"><![CDATA[<h1 id="Decision-Tree"><a href="#Decision-Tree" class="headerlink" title="Decision Tree"></a>Decision Tree</h1><blockquote><ul><li>非参数学习</li><li>可以解决分类问题</li><li>天然可以解决多分类问题</li><li>可以解决回归问题</li><li>非常好的可解释性</li></ul></blockquote><h2 id="什么是决策树"><a href="#什么是决策树" class="headerlink" title="什么是决策树"></a>什么是决策树</h2><p>决策树的思想其实在实际生活中经常被我们用到，假设现在现在有一个公司在招聘机器学习算法工程师。可能会有如图所示的招聘流程：</p><p><img src=""></p><p>这样的流程最终形成了一个类似树的结构，在这棵树的叶子节点，其实就是我们最终的决策。</p><h2 id="使用-skicit-learn-实现决策树"><a href="#使用-skicit-learn-实现决策树" class="headerlink" title="使用 skicit-learn 实现决策树"></a>使用 skicit-learn 实现决策树</h2><h1 id="决策树的构建"><a href="#决策树的构建" class="headerlink" title="决策树的构建"></a>决策树的构建</h1><p>在构建决策树时，可能需要考虑 </p><ul><li>在哪个维度做划分 </li><li>某个维度在哪个值上做划分</li></ul><p>在选择最优划分属性时，一般来说，随着划分过程的不断进行，我们希望决策树的分支节点所包含的样本尽可能属于统一类型，即节点的“纯度”越来越高。</p><h2 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h2><ul><li>熵在信息论中代表：随机变量不确定度的度量<ul><li>熵越大，数据的不确定性越高</li><li>熵越小，数据的不确定性越低</li></ul></li></ul><p>信息熵的定义为</p><p><img src=""></p><p>其中</p><h3 id="二分类问题示例"><a href="#二分类问题示例" class="headerlink" title="二分类问题示例"></a>二分类问题示例</h3><p>假设数据集中包含两个类型，其中数据的比例分别占 p 和 1-p。根据信息熵的定义可知：</p><p>entropy = -p * log(p) - (1-p) * log(p)</p><p>该方程在程序中表示为：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">entropy</span>(<span class="hljs-params">p</span>):</span><br>  <span class="hljs-keyword">return</span> -p * np.log(p) - (<span class="hljs-number">1</span> - p) * np.log(<span class="hljs-number">1</span> - p)<br><br><span class="hljs-comment"># 设置取值范围（不能取0）</span><br>x = np.linspace(<span class="hljs-number">0.01</span>, <span class="hljs-number">0.99</span>, <span class="hljs-number">200</span>)<br><br>plt.plot(x, entropy(x))<br>plt.show()<br></code></pre></div></td></tr></table></figure><p><img src=""></p><p>由图可知，当 x = 0.5 时，该信息熵曲线取到了最大值，数据的不确定性最高。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在每一个节点上，我们希望基于某一个维度在某一个域值进行划分，使得划分后信息熵降低，以达到最好的划分。</p><h2 id="基尼系数"><a href="#基尼系数" class="headerlink" title="基尼系数"></a>基尼系数</h2><h2 id="信息熵-vs-基尼系数"><a href="#信息熵-vs-基尼系数" class="headerlink" title="信息熵 vs 基尼系数"></a>信息熵 vs 基尼系数</h2><p>决策树在建立的过程中，每一个节点都需要对数据进行划分。</p><ul><li><p>信息熵的计算比基尼系数稍慢。</p></li><li><p>scikit-learn 中默认为基尼系数。</p></li><li><p>大多数情况下，二者没有特别的效果优劣。</p></li></ul><h1 id="CART"><a href="#CART" class="headerlink" title="CART"></a>CART</h1><p>scikit-learn 的决策树实现</p><p>Classification And Regression Tree</p><p>根据某一个维度 d 和某一个阈值 v 进行二分</p><ul><li>预测复杂度<ul><li>O(logm)</li></ul></li><li>训练复杂度<ul><li>O(n*m*logm)</li><li>n 每一维度</li><li>m 每个样本数据</li></ul></li></ul><p>需要进行剪枝</p><ul><li>降低复杂度</li><li>解决过拟合</li></ul><h1 id="决策树解决分类问题"><a href="#决策树解决分类问题" class="headerlink" title="决策树解决分类问题"></a>决策树解决分类问题</h1><h1 id="决策树的局限性"><a href="#决策树的局限性" class="headerlink" title="决策树的局限性"></a>决策树的局限性</h1>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>梯度下降法</title>
    <link href="/posts/538d56f6/"/>
    <url>/posts/538d56f6/</url>
    
    <content type="html"><![CDATA[<h1 id="Gradient-Descent"><a href="#Gradient-Descent" class="headerlink" title="Gradient Descent"></a>Gradient Descent</h1><ul><li>不是一个机器学习算法</li><li>是一种基于收缩的最优化方法</li><li>作用：最小化一个损失函数</li><li>梯度上升法：最大化一个效用函数</li></ul><h1 id="模拟实现梯度下降法"><a href="#模拟实现梯度下降法" class="headerlink" title="模拟实现梯度下降法"></a>模拟实现梯度下降法</h1><h1 id="线性回归的梯度下降"><a href="#线性回归的梯度下降" class="headerlink" title="线性回归的梯度下降"></a>线性回归的梯度下降</h1><h1 id="梯度下降的向量化和数据标准化"><a href="#梯度下降的向量化和数据标准化" class="headerlink" title="梯度下降的向量化和数据标准化"></a>梯度下降的向量化和数据标准化</h1><h1 id="随机梯度下降法"><a href="#随机梯度下降法" class="headerlink" title="随机梯度下降法"></a>随机梯度下降法</h1><h1 id="梯度下降的准确性"><a href="#梯度下降的准确性" class="headerlink" title="梯度下降的准确性"></a>梯度下降的准确性</h1>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性回归算法</title>
    <link href="/posts/28db4216/"/>
    <url>/posts/28db4216/</url>
    
    <content type="html"><![CDATA[<h1 id="LinearRegression"><a href="#LinearRegression" class="headerlink" title="LinearRegression"></a>LinearRegression</h1><ul><li>解决回归问题</li><li>思想简单，实现容易</li><li>许多强大的非线性模型的基础</li><li>结果具有很好的解释性</li><li>蕴含机器学习中的很多重要的思想</li></ul><h1 id="简单线性回归"><a href="#简单线性回归" class="headerlink" title="简单线性回归"></a>简单线性回归</h1><p>如图所示，在坐标中，每一个点都表示一个数据。</p><p><img src=""></p><ul><li>横轴：房屋面积</li><li>纵轴：房屋价格</li></ul><p>每个点表示房屋面积所对应的价格。</p><p><img src=""></p><p>线性回归算法认为 房屋面积 与 价格 具备线性关系。可以寻找到一条直线，最大程度“拟合”样本特征和样本输出标记之间的关系。</p><p><img src=""></p><p>简单线性回归问题每个样本只有横轴一个特征（房屋面积），输出标记为纵轴（价格）。<br>如果需要研究两个样本特征，需要在三维的空间中研究。</p><p><img src=""></p><p>在这里，我们假设找到了最佳拟合直线方程</p><p><img src=""></p><p>则对于每一个样本点 </p><p><img src=""></p><p>根据我们的直线方程，预测值为：</p><p><img src=""></p><p>真值为：</p><p><img src=""></p><p>我们希望的是 </p><p><img src=""> </p><p>之间的差距尽量小</p><p>为表达差距，我们使用如下方程表示</p><p><img src=""></p><p>通过平方之后，不仅消除了正负，而且函数处处可导。</p><h1 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h1><h2 id="利用-scikit-learn-实现"><a href="#利用-scikit-learn-实现" class="headerlink" title="利用 scikit-learn 实现"></a>利用 scikit-learn 实现</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> datasets<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><br>lin_reg = LinearRegression()<br>lin_reg.fit(X_train, y_train)<br></code></pre></div></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>线性回归是典型的参数学习</p><ul><li>对比 kNN：非参数学习</li></ul></li><li><p>只能解决回归问题</p><ul><li>但是在很多分类方法中，线性回归是基础（如逻辑回归）</li><li>对比 kNN：即可解决分类问题，也可解决回归问题</li></ul></li><li><p>对数据有假设：线性</p><ul><li>对比 kNN：对数据没有假设</li></ul></li><li><p>优点：对数据具有强解释性</p></li></ul><h2 id="线性回归-可解释性说明"><a href="#线性回归-可解释性说明" class="headerlink" title="线性回归 可解释性说明"></a>线性回归 可解释性说明</h2>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kNN - k近邻算法</title>
    <link href="/posts/ec424a85/"/>
    <url>/posts/ec424a85/</url>
    
    <content type="html"><![CDATA[<h1 id="k-Nearest-Neighbors"><a href="#k-Nearest-Neighbors" class="headerlink" title="k-Nearest Neighbors"></a>k-Nearest Neighbors</h1><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在如图所示的坐标中，样本特征 </p><ul><li>横轴：肿瘤大小</li><li>纵轴：时间</li></ul><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/kNN/knn1.jpg" alt="knn1"></p><p>每个病人的肿瘤大小和时间构成了特征空间中的每一个点。其中：</p><ul><li>红色：良性肿瘤</li><li>蓝色：恶性肿瘤 </li></ul><p>这些病人的信息构成了初始信息。</p><p>若现在有一个新的病人（绿色），接下来我们通过 kNN 算法去判断新病人是良性肿瘤还是恶性肿瘤。</p><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/kNN/knn2.jpg" alt="knn2"></p><p>现在取一个k值，假设 k=3（具体取法后面介绍，现在假设是根据经验所做出的选择）。</p><p>kNN 算法做的是：在所有的点中，寻找距离新点最近的三个点（k=3），以他们的结果进行投票，以此判断出新节点的类型。</p><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/kNN/knn3.jpg" alt="knn3"></p><p>在该例中，距离新病人（绿色）最近的3个点（k=3）都是恶性肿瘤，所以依据 kNN 算法投票，新样本有很大概率是恶性肿瘤。</p><p>kNN 解决的这类问题，是监督学习中的分类问题。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt<br><br><span class="hljs-comment"># 初始信息</span><br>raw_data_X = [<br>    [<span class="hljs-number">3.393533211</span>, <span class="hljs-number">2.331273381</span>],<br>    [<span class="hljs-number">3.110073483</span>, <span class="hljs-number">1.781539638</span>],<br>    [<span class="hljs-number">1.343808831</span>, <span class="hljs-number">3.368360954</span>],<br>    [<span class="hljs-number">3.582294042</span>, <span class="hljs-number">4.679179110</span>],<br>    [<span class="hljs-number">2.280362439</span>, <span class="hljs-number">2.866990263</span>],<br>    [<span class="hljs-number">7.423436942</span>, <span class="hljs-number">4.696522875</span>],<br>    [<span class="hljs-number">5.745051997</span>, <span class="hljs-number">3.533989803</span>],<br>    [<span class="hljs-number">9.172168622</span>, <span class="hljs-number">2.511101045</span>],<br>    [<span class="hljs-number">7.792783481</span>, <span class="hljs-number">3.424088941</span>],<br>    [<span class="hljs-number">7.939820817</span>, <span class="hljs-number">0.791637231</span>]<br>]<br><br><span class="hljs-comment"># 0 良性肿瘤  1 恶性肿瘤</span><br>raw_data_y = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br><br><br>X_train = np.array(raw_data_X)<br>y_train = np.array(raw_data_y)<br></code></pre></div></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 将初始信息绘制在坐标中</span><br>plt.scatter(X_train[y_train==<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], X_train[y_train==<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], color=<span class="hljs-string">&#x27;g&#x27;</span>)<br>plt.scatter(X_train[y_train==<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], X_train[y_train==<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], color=<span class="hljs-string">&#x27;r&#x27;</span>)<br>plt.show()<br></code></pre></div></td></tr></table></figure><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/kNN/coordinate_axes_1.png" alt="coordinate_axes_1"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 预测新病人</span><br>x = np.array([<span class="hljs-number">8.093607318</span>, <span class="hljs-number">3.365731514</span>])<br><br>plt.scatter(X_train[y_train==<span class="hljs-number">0</span>, <span class="hljs-number">0</span>], X_train[y_train==<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], color=<span class="hljs-string">&#x27;g&#x27;</span>)<br>plt.scatter(X_train[y_train==<span class="hljs-number">1</span>, <span class="hljs-number">0</span>], X_train[y_train==<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], color=<span class="hljs-string">&#x27;r&#x27;</span>)<br>plt.scatter(x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>], color=<span class="hljs-string">&#x27;b&#x27;</span>)<br>plt.show()<br></code></pre></div></td></tr></table></figure><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/kNN/coordinate_axes_2.png" alt="coordinate_axes_2"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 依据 kNN 算法 获取每个点的距离</span><br>distances = [sqrt(np.<span class="hljs-built_in">sum</span>((x_train - x)**<span class="hljs-number">2</span>)) <span class="hljs-keyword">for</span> x_train <span class="hljs-keyword">in</span> X_train]<br></code></pre></div></td></tr></table></figure><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/kNN/distances.png" alt="distances"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 取 k 值</span><br>k = <span class="hljs-number">6</span><br><br>nearest = np.argsort(distances)<br><br>topK_y = [y_train[nerghbor] <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> nearest[:k]]<br></code></pre></div></td></tr></table></figure><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/kNN/topK_y.png" alt="topK_y"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><span class="hljs-comment"># 获取投票</span><br>votes = Counter(topK_y)<br></code></pre></div></td></tr></table></figure><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/kNN/votes.png" alt="votes"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">predict_y = votes.most_common(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br></code></pre></div></td></tr></table></figure><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/kNN/predict_y.png" alt="predict_y"></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><br><br>raw_data_X = [<br>    [<span class="hljs-number">3.393533211</span>, <span class="hljs-number">2.331273381</span>],<br>    [<span class="hljs-number">3.110073483</span>, <span class="hljs-number">1.781539638</span>],<br>    [<span class="hljs-number">1.343808831</span>, <span class="hljs-number">3.368360954</span>],<br>    [<span class="hljs-number">3.582294042</span>, <span class="hljs-number">4.679179110</span>],<br>    [<span class="hljs-number">2.280362439</span>, <span class="hljs-number">2.866990263</span>],<br>    [<span class="hljs-number">7.423436942</span>, <span class="hljs-number">4.696522875</span>],<br>    [<span class="hljs-number">5.745051997</span>, <span class="hljs-number">3.533989803</span>],<br>    [<span class="hljs-number">9.172168622</span>, <span class="hljs-number">2.511101045</span>],<br>    [<span class="hljs-number">7.792783481</span>, <span class="hljs-number">3.424088941</span>],<br>    [<span class="hljs-number">7.939820817</span>, <span class="hljs-number">0.791637231</span>]<br>]<br>raw_data_y = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br><br>X_train = np.array(raw_data_X)<br>y_train = np.array(raw_data_y)<br><br>x = np.array([<span class="hljs-number">8.093607318</span>, <span class="hljs-number">3.365731514</span>])<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kNN_classify</span>(<span class="hljs-params">k, X_train, y_train, x</span>):</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">1</span> &lt;= k &lt;= X_train.shape[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;k must be valid&quot;</span><br>    <span class="hljs-keyword">assert</span> X_train.shape[<span class="hljs-number">0</span>] == y_train.shape[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;the size of X_train must equel to the size of y_train&quot;</span><br>    <span class="hljs-keyword">assert</span> X_train.shape[<span class="hljs-number">1</span>] == x.shape[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;the feature number of x must be equal to X_train&quot;</span><br><br>    distances = [sqrt(np.<span class="hljs-built_in">sum</span>((x_train - x) ** <span class="hljs-number">2</span>)) <span class="hljs-keyword">for</span> x_train <span class="hljs-keyword">in</span> X_train]<br>    nearest = np.argsort(distances)<br><br>    topK_y = [y_train[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nearest[:k]]<br>    votes = Counter(topK_y)<br><br>    <span class="hljs-keyword">return</span> votes.most_common(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br></code></pre></div></td></tr></table></figure><h1 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h1><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/kNN/knn4.png" alt="knn4"></p><p>kNN 算法非常特殊的，是一个不需要训练过程的算法，可以被认为是没有模型的算法。</p><p>为了与其他算法统一，可以认为训练数据集就是模型本身。</p><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/kNN/knn5.png" alt="knn5"></p><h2 id="使用-scikit-learn"><a href="#使用-scikit-learn" class="headerlink" title="使用 scikit-learn"></a>使用 scikit-learn</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><br>raw_data_X = [<br>    [<span class="hljs-number">3.393533211</span>, <span class="hljs-number">2.331273381</span>],<br>    [<span class="hljs-number">3.110073483</span>, <span class="hljs-number">1.781539638</span>],<br>    [<span class="hljs-number">1.343808831</span>, <span class="hljs-number">3.368360954</span>],<br>    [<span class="hljs-number">3.582294042</span>, <span class="hljs-number">4.679179110</span>],<br>    [<span class="hljs-number">2.280362439</span>, <span class="hljs-number">2.866990263</span>],<br>    [<span class="hljs-number">7.423436942</span>, <span class="hljs-number">4.696522875</span>],<br>    [<span class="hljs-number">5.745051997</span>, <span class="hljs-number">3.533989803</span>],<br>    [<span class="hljs-number">9.172168622</span>, <span class="hljs-number">2.511101045</span>],<br>    [<span class="hljs-number">7.792783481</span>, <span class="hljs-number">3.424088941</span>],<br>    [<span class="hljs-number">7.939820817</span>, <span class="hljs-number">0.791637231</span>]<br>]<br>raw_data_y = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br><br>X_train = np.array(raw_data_X)<br>y_train = np.array(raw_data_y)<br><br>x = np.array([<span class="hljs-number">8.093607318</span>, <span class="hljs-number">3.365731514</span>])<br><span class="hljs-comment"># 1:只有一个数据  -1: numpy 自动决定第二个维度是多少</span><br>X_predict = x.reshape(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>)  <span class="hljs-comment"># array([[8.093607318, 3.365731514]])</span><br><br><br>kNN_classifier = KNeighborsClassifier(n_neighbors=<span class="hljs-number">6</span>)<br>kNN_classifier.fit(X_train, y_train)<br><span class="hljs-comment"># predict 需要一个二维数组（多个数据）</span><br>y_predict = kNN_classifier.predict(X_predict)<br><br><span class="hljs-comment"># y_predict[0]</span><br></code></pre></div></td></tr></table></figure><h1 id="自己封装-kNN"><a href="#自己封装-kNN" class="headerlink" title="自己封装 kNN"></a>自己封装 kNN</h1><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt<br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">kNNClassifier</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, k</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;初始化kNN分类器&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">assert</span> k &gt;= <span class="hljs-number">1</span>, <span class="hljs-string">&quot;k must be valid&quot;</span><br><br>        self.k = k<br>        self._X_train = <span class="hljs-literal">None</span><br>        self._y_train = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fit</span>(<span class="hljs-params">self, X_train, y_train</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;根据训练集数据 X_train y_train 训练 kNN 分类器&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">assert</span> X_train.shape[<span class="hljs-number">0</span>] == y_train.shape[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;the size of X_train must be equal to the size of y_train&quot;</span><br>        <span class="hljs-keyword">assert</span> self.k &lt;= X_train.shape[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;the size of X_train must be at least k.&quot;</span><br><br>        self._X_train = X_train<br>        self._y_train = y_train<br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">predict</span>(<span class="hljs-params">self, X_predict</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;给定待预测数据集 X_predict，返回表示 X_predict 的结果向量&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">assert</span> self._X_train <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> self._y_train <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>, <span class="hljs-string">&quot;must fit before predict!&quot;</span><br>        <span class="hljs-comment"># X_train 和 X_predict 必须维度相同</span><br>        <span class="hljs-keyword">assert</span> X_predict.shape[<span class="hljs-number">1</span>] == self._X_train.shape[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;the feature number of X_predict must be equal to X_train&quot;</span><br><br>        y_predict = [self._predict(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> X_predict]<br>        <span class="hljs-keyword">return</span> np.array(y_predict)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_predict</span>(<span class="hljs-params">self, x</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;给定单个带预测数据x，返回x的预测结果值&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">assert</span> x.shape[<span class="hljs-number">0</span>] == self._X_train.shape[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;the feature number of x must be equal to X_train&quot;</span><br><br>        distances = [sqrt(np.<span class="hljs-built_in">sum</span>((x_train - x) ** <span class="hljs-number">2</span>)) <span class="hljs-keyword">for</span> x_train <span class="hljs-keyword">in</span> self._X_train]<br>        nearest = np.argsort(distances)<br><br>        topK_y = [self._y_train[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nearest[:self.k]]<br>        votes = Counter(topK_y)<br><br>        <span class="hljs-keyword">return</span> votes.most_common(<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;KNN(k=%d)&quot;</span> % self.k<br></code></pre></div></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>解决分类问题</li><li>天然可以解决多分类问题</li><li>思想简单，效果强大</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>最大缺点：效率低下</li></ul><p>如果训练集有 m 个样本，n 个特征，则预测每一个新的数据，需要 O(m*n) 复杂度</p><p>优化：使用树结构 KD-Tree Ball-Tree</p><ul><li>高度数据相关</li></ul><p>如 k=3 时，若预测结果中刚刚有两个错误数据，则将预测错误</p><ul><li><p>预测结果不具有可解释性</p></li><li><p>维数灾难</p></li></ul><p>随着维度的增加，“看似相近”的两个点的距离越来越大</p><p><img src=""></p><p>优化：降维</p><h2 id="使用-kNN-解决回归问题"><a href="#使用-kNN-解决回归问题" class="headerlink" title="使用 kNN 解决回归问题"></a>使用 kNN 解决回归问题</h2><p><img src=""></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NumPy</title>
    <link href="/posts/ae6d8d24/"/>
    <url>/posts/ae6d8d24/</url>
    
    <content type="html"><![CDATA[<h1 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h1><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h1 id="数组-numpy-array"><a href="#数组-numpy-array" class="headerlink" title="数组 numpy.array"></a>数组 numpy.array</h1><h4 id="np-zeros"><a href="#np-zeros" class="headerlink" title="np.zeros"></a>np.zeros</h4><p>创建指定大小的数组，数组元素以 0 填充。</p><blockquote><ul><li>numpy.zeros(shape, dtype=None, order = ‘C’)</li></ul></blockquote><ul><li>shape  数组形状</li><li>dtype  数据类型</li><li>order  ‘C’ 用于 C 的行数组，或者 ‘F’ 用于 FORTRAN 的列数组</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">np.zero(<span class="hljs-number">5</span>)<br><span class="hljs-comment"># [0. 0. 0. 0. 0.]</span><br><br>np.zero(<span class="hljs-number">5</span>, dtype=<span class="hljs-built_in">int</span>)<br><span class="hljs-comment"># [0 0 0 0 0]</span><br><br>np.zero((<span class="hljs-number">3</span>, <span class="hljs-number">5</span>))       <span class="hljs-comment"># 三行五列</span><br>np.zero(shape=(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>))<br><span class="hljs-comment"># [</span><br><span class="hljs-comment">#   [0., 0., 0., 0., 0.],</span><br><span class="hljs-comment">#   [0., 0., 0., 0., 0.],</span><br><span class="hljs-comment">#   [0., 0., 0., 0., 0.],</span><br><span class="hljs-comment"># ]</span><br></code></pre></div></td></tr></table></figure><h4 id="np-ones"><a href="#np-ones" class="headerlink" title="np.ones"></a>np.ones</h4><p>创建指定大小的数组，数组元素以 1 填充。</p><blockquote><ul><li>numpy.ones(shape, dtype=None, order=’C’)</li></ul></blockquote><h4 id="np-full"><a href="#np-full" class="headerlink" title="np.full"></a>np.full</h4><p>创建指定大小和数据的数组</p><blockquote><ul><li>numpy.full(shape, fill_value, dtype=None, order=’C’)</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个 三行五列 值为 666.0 的矩阵</span><br>np.full((<span class="hljs-number">3</span>, <span class="hljs-number">5</span>), <span class="hljs-number">666.0</span>)<br></code></pre></div></td></tr></table></figure><h4 id="np-arange"><a href="#np-arange" class="headerlink" title="np.arange"></a>np.arange</h4><p>在数组中，可以使用 range 创建指定范围的数组（不能传递浮点数）。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># [0, 20)  步长为 2</span><br>[i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">2</span>)]<br><br><span class="hljs-comment"># [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]</span><br></code></pre></div></td></tr></table></figure><p>在 numpy 中，可以使用 arange 创建数组范围并返回 ndarray 对象。</p><blockquote><ul><li>numpy.arange(start, stop, step, dtype)</li></ul></blockquote><ul><li>start  起始值，默认为 0</li><li>stop   终止值，不包含</li><li>step   步长，默认为 1</li><li>dtype  数据类型</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 可以传递浮点数</span><br>np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.2</span>)<br><span class="hljs-comment"># [0., 0.2, 0.4, 0.6, 0.8]</span><br></code></pre></div></td></tr></table></figure><h4 id="np-linspace"><a href="#np-linspace" class="headerlink" title="np.linspace"></a>np.linspace</h4><p>创建一个一维数组，构成一个等差数列。</p><blockquote><ul><li>numpy.linspace(start, stop, num=50, endpoint=True, retstep=False,dtype=None, axis=0)</li></ul></blockquote><ul><li>start       起始值</li><li>stop        终止值（默认包含 endpoint=True）</li><li>endpoint    当为 True 时，会包含 stop 的值</li><li>retstep     当为 True 时，生成的数组中会显示间距</li><li>dtype       数据类型</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 生成 [0, 20] 间距为 2 的 10 个数</span><br>np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">11</span>)<br><span class="hljs-comment"># [0., 2., 4., 6., 8., 10., 12., 14., 16., 18., 20.]</span><br></code></pre></div></td></tr></table></figure><h4 id="np-random"><a href="#np-random" class="headerlink" title="np.random"></a>np.random</h4><blockquote><ul><li>numpy.random.randint(low, high=None, size=None, dtype=None)</li></ul></blockquote><p>生成指定的整数。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 在 [0, 10) 间生成一个随机数</span><br>np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)<br><br><span class="hljs-comment"># 在 [0, 10) 间生成一个大小为 10 的一维数组</span><br>np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, size=<span class="hljs-number">10</span>)<br><span class="hljs-comment"># [7, 7, 7, 7, 7, 4, 5, 6, 4, 7]</span><br><br><span class="hljs-comment"># 在 [0, 10) 间生成一个 3行6列 的矩阵</span><br>np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, size=(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>))<br><br><br><span class="hljs-comment"># 指定随机种子，使生成的数据在测试时保持一致</span><br>np.random.seed(<span class="hljs-number">666</span>)<br></code></pre></div></td></tr></table></figure><blockquote><ul><li>numpy.random.random(size=None)</li></ul></blockquote><p>生成 [0.0, 1.0) 间的浮点数。</p><blockquote><ul><li>numpy.random.normal(loc=0.0, scale=1.0, size=None)</li></ul></blockquote><p>生成一个符合正态分布的浮点数。</p><ul><li>loc     均值</li><li>scale   方差</li><li>size    大小</li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 生成 均值为 10 方差为 100 的浮点数</span><br>np.random.normal(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>)<br><br><span class="hljs-comment"># 生成 均值为 0 方差为 1 的 3行5列的矩阵</span><br>np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">5</span>))<br></code></pre></div></td></tr></table></figure><h1 id="numpy-array-基本操作"><a href="#numpy-array-基本操作" class="headerlink" title="numpy.array 基本操作"></a>numpy.array 基本操作</h1><p>假设有如下一个一维的数组 x 和 一个三行五列的矩阵 X：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>np.random.seed(<span class="hljs-number">0</span>)<br><br>x = np.arange(<span class="hljs-number">10</span>)<br><span class="hljs-comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><br>X = np.arange(<span class="hljs-number">15</span>).reshape(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><span class="hljs-comment"># [</span><br><span class="hljs-comment">#   [ 0,  1,  2,  3,  4],</span><br><span class="hljs-comment">#   [ 5,  6,  7,  8,  9],</span><br><span class="hljs-comment">#   [10, 11, 12, 13, 14]</span><br><span class="hljs-comment"># ]</span><br></code></pre></div></td></tr></table></figure><h2 id="Reshape"><a href="#Reshape" class="headerlink" title="Reshape"></a>Reshape</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 将 x 转置为 2行5列的 矩阵</span><br>A = x.reshape(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>)<br><span class="hljs-comment"># [</span><br><span class="hljs-comment">#   [0, 1, 2, 3, 4],</span><br><span class="hljs-comment">#   [5, 6, 7, 8, 9]</span><br><span class="hljs-comment"># ] </span><br><br><span class="hljs-comment"># 将向量装置成矩阵</span><br>B = x.reshape(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br><span class="hljs-comment"># [</span><br><span class="hljs-comment">#   [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="hljs-comment"># ]</span><br><br><span class="hljs-comment"># -1：让 numpy 自己决定维度</span><br><span class="hljs-comment"># 10列</span><br>C = x.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br><span class="hljs-comment"># [</span><br><span class="hljs-comment">#   [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="hljs-comment"># ]</span><br><br><span class="hljs-comment"># 10行</span><br>D = x.reshape(<span class="hljs-number">10</span>, -<span class="hljs-number">1</span>)<br><span class="hljs-comment"># [</span><br><span class="hljs-comment">#   [0],</span><br><span class="hljs-comment">#   [1],</span><br><span class="hljs-comment">#   [2],</span><br><span class="hljs-comment">#   [3],</span><br><span class="hljs-comment">#   [4],</span><br><span class="hljs-comment">#   [5],</span><br><span class="hljs-comment">#   [6],</span><br><span class="hljs-comment">#   [7],</span><br><span class="hljs-comment">#   [8],</span><br><span class="hljs-comment">#   [9],</span><br><span class="hljs-comment"># ]</span><br><br><span class="hljs-comment"># 2行</span><br>E = x.reshape(<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>)<br><span class="hljs-comment"># [</span><br><span class="hljs-comment">#   [0, 1, 2, 3, 4],</span><br><span class="hljs-comment">#   [5, 6, 7, 8, 9]</span><br><span class="hljs-comment"># ]</span><br><br><span class="hljs-comment"># 数据不能整除的情况下，不能 reshape</span><br>F = x.reshape(<span class="hljs-number">3</span>, -<span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure><h2 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># ndarray.ndim    秩，即轴的数量或维度的数量</span><br>x.ndim<br><span class="hljs-comment"># 1</span><br>X.ndim<br><span class="hljs-comment"># 2</span><br><br><span class="hljs-comment"># ndarray.shape   数组维度，对于矩阵为n行m列</span><br>x.shape<br><span class="hljs-comment"># (10, )</span><br>X.shape<br><span class="hljs-comment"># (3, 5)</span><br><br><span class="hljs-comment"># ndarray.size    数组元素的总个数，对于矩阵为 n*m 个</span><br>x.size<br><span class="hljs-comment"># 10</span><br>X.size<br><span class="hljs-comment"># 15</span><br></code></pre></div></td></tr></table></figure><h2 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h2><p>一维 numpy.array 可以和数组一样进行访问。</p><p>多维 numpy.array 在访问时，推荐传入多个参数。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 一维</span><br>x[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 0</span><br><br><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习基础</title>
    <link href="/posts/4aa284f3/"/>
    <url>/posts/4aa284f3/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/basics/machinelearning.png" alt="machinelearning"></p><h1 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h1><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/basics/lris_table.png" alt="lris_table"></p><p>如图所示表格，是鸢尾花（lris）相关信息的数据，其中：</p><ul><li>数据整体称为数据集（data set）</li><li>每一行数据称为一个样本（sample）</li><li>每一列（除表格最后一列）表达样本的一个特征（feature）</li><li>最后一列，成为标记（label）</li></ul><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/basics/lris_feature.png" alt="lris_feature"></p><p>如图所示信息，其中 萼片长度、宽度，花瓣的长度、宽度称为 特征；每一行特征的值称为特征向量（数学上通常会将其表示为列向量）。</p><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/basics/lris_feature2.png" alt="lris_feature2"></p><p>若将该图中的数据表示为矩阵的方式，结果如图：</p><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/basics/lris_array.png" alt="lris_array"></p><p>选择两种鸢尾花的特征为例，将其表示为如图的二维空间（多维特征将其表示为多维空间）。</p><p>我们将这样的空间称为 特征空间（feature space）。</p><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/basics/lris_feature_space.png" alt="lris_feature_space"></p><p>分类任务本质就是在特征空间切分，如图所示，在特征空间中，将鸢尾花根据两种特征分为了两类。</p><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/basics/lris_feature_space2.png" alt="lris_feature_space2"></p><h1 id="机器学习的基本任务"><a href="#机器学习的基本任务" class="headerlink" title="机器学习的基本任务"></a>机器学习的基本任务</h1><p>机器学习的基本任务基本有两类，分别为：</p><blockquote><ul><li>分类</li><li>回归</li></ul></blockquote><h2 id="分类任务"><a href="#分类任务" class="headerlink" title="分类任务"></a>分类任务</h2><blockquote><ul><li> 一些算法只支持完成二分类的任务</li><li> 多分类的任务可以转换成二分类的任务</li><li> 一些算法天然的支持多分类问题</li></ul></blockquote><h3 id="二分类"><a href="#二分类" class="headerlink" title="二分类"></a>二分类</h3><p>二分类问题的常见实例：</p><ul><li>判断邮件是垃圾邮件；不是垃圾邮件</li><li>判断发放给客户信用卡有风险；无风险</li><li>判断病患良性肿瘤；恶性肿瘤</li><li>判断某支股票涨；跌</li></ul><h3 id="多分类"><a href="#多分类" class="headerlink" title="多分类"></a>多分类</h3><p>多分类问题的常见实例：</p><ul><li>数字识别</li><li>图像识别</li><li>判断发放给客户信用卡的风险评级</li><li>围棋游戏等</li><li>自动驾驶识别</li></ul><h3 id="多标签分类"><a href="#多标签分类" class="headerlink" title="多标签分类"></a>多标签分类</h3><p>如图所示，为多标签分类问题的常见实例：</p><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/basics/label_classification.png" alt="label_classification"></p><h2 id="回归任务"><a href="#回归任务" class="headerlink" title="回归任务"></a>回归任务</h2><p>回归问题的结果与分类问题的结果不同，回归问题的结果是一个连续数字的值，而非一个类别。</p><p>常见的回归问题有：</p><ul><li>房屋价格</li><li>市场分析</li><li>学术成绩</li><li>股票价格</li></ul><p>在一些情况下，回归任务可以简化成分类任务。</p><h1 id="机器学习算法分类"><a href="#机器学习算法分类" class="headerlink" title="机器学习算法分类"></a>机器学习算法分类</h1><h2 id="监督学习-supervised-learning"><a href="#监督学习-supervised-learning" class="headerlink" title="监督学习 supervised learning"></a>监督学习 supervised learning</h2><p>监督学习主要处理的是分类问题和回归问题。</p><p>监督学习的含义是给机器的训练数据中拥有“标记”或者“答案”。根据这些数据进行模型的训练。</p><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/basics/supervised_learning.png" alt="supervised_learning"></p><ul><li>如根据图片判断猫狗（图像已经拥有了标定信息）</li></ul><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/basics/supervised_learning_2.png" alt="supervised_learning_2"></p><ul><li>如更具手写字体识别数字（给出结果标记）</li></ul><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/basics/supervised_learning_3.png" alt="supervised_learning_3"></p><ul><li><p>银行已经积累了一定的客户信息和他们信用卡的信用情况</p></li><li><p>医院已经积累了一定的病人信息和他们最终确诊是否患病的情况。</p></li></ul><p>常见的监督学习算法有：</p><blockquote><ul><li>k近邻</li><li> 线性回归和多项式回归</li><li> 逻辑回归</li><li> SVM</li><li> 决策树和随机森林</li></ul></blockquote><h2 id="非监督学习-unsupervised-learning"><a href="#非监督学习-unsupervised-learning" class="headerlink" title="非监督学习 unsupervised learning"></a>非监督学习 unsupervised learning</h2><p>非监督学习给机器的训练数据没有任何“标记”或者“答案”。</p><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/basics/unsupervised_learning.png" alt="unsupervised_learning"></p><p>对没有“标记”的数据进行分类 – 聚类分析。</p><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/basics/unsupervised_learning_2.png" alt="unsupervised_learning_2"></p><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><h4 id="对数据进行降维处理"><a href="#对数据进行降维处理" class="headerlink" title="对数据进行降维处理"></a>对数据进行降维处理</h4><ul><li>特征提取：行用卡的信用评级和人的胖瘦无关？</li><li>特征压缩：PCA</li></ul><p>降维处理的意义：方便可视化 </p><p>我们无法理解四维以上空间，所以可以将其降维到三维或者二维空间，方便理解。</p><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/basics/unsupervised_learning_3.png" alt="unsupervised_learning_3"></p><h4 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h4><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/basics/unsupervised_learning_4.png" alt="unsupervised_learning_4"></p><h2 id="半监督学习-semi-supervised-learning"><a href="#半监督学习-semi-supervised-learning" class="headerlink" title="半监督学习 semi-supervised learning"></a>半监督学习 semi-supervised learning</h2><ul><li><p>一部分数据有“标记”或者答案，另一部分数据没有</p></li><li><p>常见的场景：各种原因产生的标记缺失。</p></li><li><p>我们通常都先使用无监督学习手段对数据做处理，之后使用监督学习手段做模型的训练和预测。</p></li></ul><h2 id="增强学习"><a href="#增强学习" class="headerlink" title="增强学习"></a>增强学习</h2><p>根据周围环境的情况，采取行动，根据采取行动的结果，学习行动方式。</p><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/basics/reinforcement_learning.png" alt="reinforcement_learning"></p><ul><li>无人驾驶</li><li>机器人</li></ul><p>在增强学习中，监督学习和半监督学习是基础。</p><h1 id="机器学习的其他分类"><a href="#机器学习的其他分类" class="headerlink" title="机器学习的其他分类"></a>机器学习的其他分类</h1><h2 id="在线学习和批量学习（离线学习）"><a href="#在线学习和批量学习（离线学习）" class="headerlink" title="在线学习和批量学习（离线学习）"></a>在线学习和批量学习（离线学习）</h2><h3 id="批量学习-Batch-Learning-Offline-Learning"><a href="#批量学习-Batch-Learning-Offline-Learning" class="headerlink" title="批量学习 Batch Learning / Offline Learning"></a>批量学习 Batch Learning / Offline Learning</h3><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/basics/batch_learning.png" alt="batch_learning"></p><ul><li><p>优点：简单</p></li><li><p>问题：要考虑如如何适应环境变化</p><ul><li>解决方案：定时重新批量学习</li></ul></li><li><p>缺点：每次重新批量学习，运行量巨大。在某些环境变化非常快的情况下，甚至是不可能的。</p></li></ul><h3 id="在线学习-Online-Learning"><a href="#在线学习-Online-Learning" class="headerlink" title="在线学习 Online Learning"></a>在线学习 Online Learning</h3><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/basics/online_learning.png" alt="online_learning"></p><ul><li><p>优点：及时反映新的环境变化</p></li><li><p>问题：新的数据可能带来不好的变化，错误的数据可能带来错误的结果</p><ul><li>解决方案：需要加强对数据的监控</li></ul></li><li><p>也适用于数据量巨大，完全无法批量学习的环境</p></li></ul><h2 id="参数学习和非参数学习"><a href="#参数学习和非参数学习" class="headerlink" title="参数学习和非参数学习"></a>参数学习和非参数学习</h2><h3 id="参数学习-Parametric-Learning"><a href="#参数学习-Parametric-Learning" class="headerlink" title="参数学习 Parametric Learning"></a>参数学习 Parametric Learning</h3><p>如图所示，为房屋面积与价格的关系曲线。</p><p><img src="https://source.letitout.cloud/images/articles/2020/09/MachineLearning/basics/parametric_learning.png" alt="parametric_learning"></p><p>特点：一旦学习到了参数，就不需要原有的数据集。</p><h3 id="非参数学习-Nonparametric-Learning"><a href="#非参数学习-Nonparametric-Learning" class="headerlink" title="非参数学习 Nonparametric Learning"></a>非参数学习 Nonparametric Learning</h3><ul><li><p>不对模型进行过多假设</p></li><li><p>非参数不等于没有参数，而是对整个不进行建模，不学习一些参数</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Hooks</title>
    <link href="/posts/712433a6/"/>
    <url>/posts/712433a6/</url>
    
    <content type="html"><![CDATA[<h1 id="React-Hooks-简介"><a href="#React-Hooks-简介" class="headerlink" title="React Hooks 简介"></a>React Hooks 简介</h1><h2 id="Hook-含义"><a href="#Hook-含义" class="headerlink" title="Hook 含义"></a>Hook 含义</h2><h1 id="组件类和函数组件"><a href="#组件类和函数组件" class="headerlink" title="组件类和函数组件"></a>组件类和函数组件</h1><h1 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> React, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-function"><span class="hljs-title">Example</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-comment">// 声明了一个 count 的 state 变量，并初始化为 0</span><br>  <span class="hljs-comment">// setCount 设置 state 值 count 的方法</span><br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br>  <br>  <span class="hljs-comment">// 每次点击按钮，将 count 的值 +1</span><br>  <span class="hljs-keyword">return</span> (<br>    &lt;&gt;<br>      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;<br>      &lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> setCount(count + <span class="hljs-number">1</span>)&#125;&gt;<br>        Click me<br>      &lt;/button&gt;<br>    &lt;/&gt;<br>  )<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Example;<br></code></pre></div></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 声明一个 state 变量，并同时初始化</span><br><span class="hljs-keyword">const</span> [state, setState] = useState(initialState)<br></code></pre></div></td></tr></table></figure><ul><li>useState 返回一个包含两个元素的数组<ul><li>state 变量，指向状态当前值</li><li>setState 更新 state 值的方法</li></ul></li><li>initialState 状态初始值可以是数字，字符串，数组，对象等</li></ul><h2 id="与类中使用-setState-异同"><a href="#与类中使用-setState-异同" class="headerlink" title="与类中使用 setState 异同"></a>与类中使用 <code>setState</code> 异同</h2><ul><li>相同点<ul><li>在一次渲染周期中调用多次 setState，数据只改变一次</li></ul></li><li>不同点<ul><li>类组件中 setState 为合并</li><li>函数组件中 setState 为替换</li></ul></li></ul><h1 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h1><p>useEffect 用来执行副作用。可以将 useEffect Hook 看做 <code>componentDidMount, componentDidUpdate, componentWillMount</code> 生命周期函数的组合。</p><p>常用在：</p><ul><li>服务器请求</li><li>访问元素 dom 元素</li><li>本地持久化缓存</li><li>绑定/解绑事件</li><li>添加订阅</li><li>设置定时器</li><li>记录日志</li><li>等</li></ul><p>useEffect 接收一个函数，该函数会在组件渲染完毕后才执行，该函数有要求：要么返回一个能清除副作用的函数，要么就不返回任何内容。</p><h2 id="不需要清除的-effect"><a href="#不需要清除的-effect" class="headerlink" title="不需要清除的 effect"></a>不需要清除的 effect</h2><p>在 React 更新 DOM 之后，我们想运行一些额外的代码。比如发送网络请求，手动变更 DOM，记录日志，这些都是常见的无需清除的操作。<br>因为我们在执行完这些操作之后，就可以忽略他们了。</p><p>以下为使用 class 和 Hook 都是怎么实现这些副作用的对比。</p><h3 id="使用类组件"><a href="#使用类组件" class="headerlink" title="使用类组件"></a>使用类组件</h3><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-comment">// 在 React 更新 DOM 操作后，立即更新 document 的 title 属性</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(props);<br>    <span class="hljs-built_in">this</span>.state = &#123;<br>      count: <span class="hljs-number">0</span><br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-comment">// 组件加载时需要更新</span><br>  <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.state.count&#125;</span> times`</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 组件更新时需要更新</span><br>  <span class="hljs-function"><span class="hljs-title">componentDidUpdate</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.state.count&#125;</span> times`</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 在 render() 不能有任何副作用。应该在 react 更新 DOM 后再执行副作用。</span><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div&gt;<br>        &lt;p&gt;You clicked &#123;<span class="hljs-built_in">this</span>.state.count&#125; times.&lt;/p&gt;<br>        &lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span>&#125;)&#125;&gt;<br>          click me.<br>        &lt;/button&gt;<br>      &lt;div/&gt;<br>    )<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="使用-Hook"><a href="#使用-Hook" class="headerlink" title="使用 Hook"></a>使用 Hook</h3><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> React, &#123;useState, useEffect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Example</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;   <span class="hljs-comment">// 经过渲染或更新， DOM 更新完毕之后，会运行该 effect</span><br>    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`You click <span class="hljs-subst">$&#123;count&#125;</span> times`</span>;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> (<br>    &lt;div&gt;<br>      &lt;p&gt;You clicked &#123;<span class="hljs-built_in">this</span>.state.count&#125; times.&lt;/p&gt;<br>      &lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span>&#125;)&#125;&gt;<br>        click me.<br>      &lt;/button&gt;<br>    &lt;div/&gt;<br>  );<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>第一次渲染之后和每次更新之后都会执行 useEffect。且 React 保证每次运行 effect 的同时，DOM 已经更新完毕。</li><li>useEffect 放在组件内部让我们可以在 effect 中直接访问 state / props。我们不需要特殊的 API 来读取。</li><li>与 componentDidMount 或 componentDidUpdate 不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。大多数情况下，effect 不需要同步地执行。在个别情况下（例如测量布局），有单独的 useLayoutEffect Hook 供你使用，其 API 与 useEffect 相同。</li></ul><h2 id="需要清除的-effect"><a href="#需要清除的-effect" class="headerlink" title="需要清除的 effect"></a>需要清除的 effect</h2><p>有一些副作用是需要清除的，如订阅外部数据源。这种情况下，清除工作是非常重要的，可以防止引起内存泄露！</p><h3 id="使用类组件-1"><a href="#使用类组件-1" class="headerlink" title="使用类组件"></a>使用类组件</h3><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FriendStatus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(props);<br>    <span class="hljs-built_in">this</span>.state = &#123; <span class="hljs-attr">isOnline</span>: <span class="hljs-literal">null</span> &#125;;<br>    <span class="hljs-built_in">this</span>.handleStatusChange = <span class="hljs-built_in">this</span>.handleStatusChange.bind(<span class="hljs-built_in">this</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;<br>    ChatAPI.subscribeToFriendStatus(<br>      <span class="hljs-built_in">this</span>.props.friend.id,<br>      <span class="hljs-built_in">this</span>.handleStatusChange<br>    );<br>  &#125;<br>  componentDidUpdate () &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">componentWillUnmount</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 在组件卸载时，关闭订阅的数据源</span><br>    ChatAPI.unsubscribeFromFriendStatus(<br>      <span class="hljs-built_in">this</span>.props.friend.id,<br>      <span class="hljs-built_in">this</span>.handleStatusChange<br>    );<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">handleStatusChange</span>(<span class="hljs-params">status</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123;<br>      isOnline: status.isOnline<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state.isOnline === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Loading...&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.state.isOnline ? <span class="hljs-string">&#x27;Online&#x27;</span> : <span class="hljs-string">&#x27;Offline&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="使用函数组件"><a href="#使用函数组件" class="headerlink" title="使用函数组件"></a>使用函数组件</h3><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> React, &#123;useState, useEffect&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FriendStatus</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [isOnline, setIsOnline] = useState(<span class="hljs-literal">null</span>);<br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleStatusChange</span>(<span class="hljs-params">status</span>) </span>&#123;<br>      setIsOnline(status.isOnline);<br>    &#125;<br><br>    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);<br>    <span class="hljs-comment">// effect 可选清除副作用的函数，返回函数不一定需要命名</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanup</span>(<span class="hljs-params"></span>) </span>&#123;<br>      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);<br>    &#125;;<br>  &#125;);<br><br>  <span class="hljs-keyword">if</span> (isOnline === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Loading...&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> isOnline ? <span class="hljs-string">&#x27;Online&#x27;</span> : <span class="hljs-string">&#x27;Offline&#x27;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>React 会在组件卸载的时候执行清除操作。</li></ul><h2 id="多个-Effect-实现关注点分离"><a href="#多个-Effect-实现关注点分离" class="headerlink" title="多个 Effect 实现关注点分离"></a>多个 Effect 实现关注点分离</h2><p>使用 Hook 的其中一个目的是要解决： class 生命周期函数中经常包含不相关逻辑，相关逻辑又分离在几个不同的方法中。</p><p>如下为上文中计数器和好友状态指示器逻辑组合在一起的组件：</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FriendStatusWithCounter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(props);<br>    <span class="hljs-built_in">this</span>.state = &#123;<br>      count: <span class="hljs-number">0</span>,<br>      isOnline: <span class="hljs-literal">null</span><br>    &#125;;<br>    <span class="hljs-built_in">this</span>.handleStautsChange = <span class="hljs-built_in">this</span>.handleStatusChange.bind(<span class="hljs-built_in">this</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 相应的逻辑被分配在三个不同的生命周期函数中</span><br>  <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// counter</span><br>    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.state.count&#125;</span> times`</span>;<br>    <span class="hljs-comment">// friend status</span><br>    ChatAPI.subscribeToFriendStatus(<br>      <span class="hljs-built_in">this</span>.props.fried.id,<br>      <span class="hljs-built_in">this</span>.handleStatusChange<br>    )<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">componentDidUpdate</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.state.count&#125;</span> times`</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">componentWillUnmount</span>(<span class="hljs-params"></span>)</span> &#123;<br>    ChatAPI.unsubscribeFromFriendStatus(<br>      <span class="hljs-built_in">this</span>.props.friend.id,<br>      <span class="hljs-built_in">this</span>.handleStatusChange<br>    );<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">handleStatusChange</span>(<span class="hljs-params">status</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123;<br>      isOnline: status.isOnline<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>若使用 Hook，和使用多个 state 的 Hook 一样，通过使用多个 effect，将不相关的逻辑分离到不同的 effect 中。</p><p>Hook 允许按照代码的用途进行分离，不同于生命周期函数。将按照 effect 声明的顺序依次调用组件中的每一个 effect。</p><figure class="highlight jsx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">const</span> FriendStatusWithCounter = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.state.count&#125;</span> times`</span>;<br>  &#125;);<br><br>  <span class="hljs-keyword">const</span> [isOneline, useIsOneline] = useState(<span class="hljs-literal">null</span>);<br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleStatusChange</span>(<span class="hljs-params">status</span>) </span>&#123;<br>      setIsOneline(status.isOneline);<br>    &#125;<br><br>    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);<br>    &#125;;<br>  &#125;);<br><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="跳过-Effect-进行性能优化"><a href="#跳过-Effect-进行性能优化" class="headerlink" title="跳过 Effect 进行性能优化"></a>跳过 Effect 进行性能优化</h2><p>在类组件中，我们可以通过 <code>componentDidUpdate</code> 中 <code>prevProps</code> 和 <code>prevState</code> 的 props / state 的变化比较，判断是否需要执行某些副作用。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">componentDidUpdate</span>(<span class="hljs-params">prevProps, prevState</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (prevState.count !== <span class="hljs-built_in">this</span>.state.count) &#123;<br>    <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.state.count&#125;</span> times`</span>;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在 Hook 中，可以通过对 useEffect 传递数组作为第二可选参数，通知 React 跳过对 effect 的调用。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">document</span>.title = <span class="hljs-string">`You clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span>;<br>&#125;, [count]);    <span class="hljs-comment">// 表示 count 更改时会进行更新</span><br><br><span class="hljs-comment">// &#123;... , [5]&#125;  当 count === 5 时，跳过 effect</span><br></code></pre></div></td></tr></table></figure><ul><li>若只想运行一次 effect（仅在组件挂载和卸载时执行），可传递一个空数组 [] 作为第二参数。<ul><li>传入一个空数组（[]），effect 内部的 props 和 state 会一直拥有其初始值。</li></ul></li><li>使用该优化，请确保数组中包含了所有外部作用域中会随时间变化且在 effect 中使用的变量，否则代码会用到先前渲染中的旧变量。</li></ul><h2 id="每次更新的时候都要运行-Effect-的原因"><a href="#每次更新的时候都要运行-Effect-的原因" class="headerlink" title="每次更新的时候都要运行 Effect 的原因"></a>每次更新的时候都要运行 Effect 的原因</h2><h1 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 Hook</h1><p>自定义 Hook 可以将组件逻辑提取到可重用的函数中。</p><p>目前为止，在 React 中有两种流行的方式共享组件之间的状态逻辑：</p><ul><li>render props</li><li>高阶组件<br>使用 Hook 可以在不增加组件的情况下解决相同的问题。</li></ul><h2 id="创建自定义-Hook"><a href="#创建自定义-Hook" class="headerlink" title="创建自定义 Hook"></a>创建自定义 Hook</h2><p>当我们想在函数间共享逻辑时，我们可以把它提取到另外一个函数中。由于组件和 Hook 都是函数，所以也同样使用于这种方式。</p><p>自定义 Hook 是一个函数，其名称以 “use” 开头，函数内部可以调用其他的 Hook。</p><p>以下是根据上文中 <code>FriendStatus</code> 实例，所提取的自定义 Hook。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-comment">// 名称一定以 use 开头</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useFriendStatus</span>(<span class="hljs-params">friendID</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [isOnline, setIsOnline] = useState(<span class="hljs-literal">null</span>);<br><br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleStatusChange</span>(<span class="hljs-params">status</span>) </span>&#123;<br>      setIsOnline(status.isOneline);<br>    &#125;<br><br>    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      ChatAPI.unsubcribeFromFriendStatus(friendID, handleStatusChange);<br>    &#125;;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> isOnline;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useFriendStatus;<br></code></pre></div></td></tr></table></figure><p>在这个自定义 Hook 中，没有包含任何新内容（逻辑与组件中的完全一致）</p><h2 id="使用自定义-Hook"><a href="#使用自定义-Hook" class="headerlink" title="使用自定义 Hook"></a>使用自定义 Hook</h2><p>与组件一致，请确保只在自定义 Hook 的顶层无条件地调用其他 Hook。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FriendStatus</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> isOnline = useFriendStatus(props.friend.id);<br><br>  <span class="hljs-keyword">if</span> (isOnline === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Loading...&quot;</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> isOnline ? <span class="hljs-string">&#x27;Online&#x27;</span> : <span class="hljs-string">&#x27;Offline&#x27;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>这段代码与之前的工作方式完全一样，我们只是将函数中需要共享的逻辑提取到单独的函数中。</p><ul><li>自定义 Hook 是一种自然遵循 Hook 设计的约定，不是 React 的特性。</li><li>自定义 Hook 必须以 “use” 开头</li><li>不同组件中使用相同的 Hook 不会共享 state。<ul><li>自定义 Hook 是重用状态逻辑的机制（例如设置为订阅并存储当前值），每次使用自定义 Hook 时，其中的所有 state 和副作用完全隔离。</li></ul></li></ul><h2 id="在多个-Hook-之间传递信息"><a href="#在多个-Hook-之间传递信息" class="headerlink" title="在多个 Hook 之间传递信息"></a>在多个 Hook 之间传递信息</h2><p>由于 Hook 本身就是函数，因此我们可以在它们之间传递信息。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 这是一个聊天消息接收者的选择器，它会显示当前选定的好友是否在线</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ChatRecipientPicker</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 当前选择的好友 ID 保存在 recipientID 状态变量中</span><br>  <span class="hljs-keyword">const</span> [recipientID, setRecipientID] = useState(<span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 当更新 recipientID 状态变量时，useFriendStatus Hook 会取消订阅之前选中的好友，并订阅新选中的好友状态</span><br>  <span class="hljs-keyword">const</span> isRecipientOnline = useFriendStatus(recipientID);<br><br>  <span class="hljs-keyword">return</span> (<br>    &lt;&gt;<br>      &lt;Circle color=&#123;isRecipientOnline ? <span class="hljs-string">&#x27;green&#x27;</span> : <span class="hljs-string">&#x27;red&#x27;</span>&#125; /&gt;<br>      &lt;select  <span class="hljs-comment">// &lt;select&gt; 中选择其他好友时更新 recipientID</span><br>        value=&#123;recipientID&#125; <br>        onChange=&#123;<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> setRecipientID(<span class="hljs-built_in">Number</span>(e.target.value))&#125;<br>      &gt;<br>        &#123;<br>          friendList.map(<span class="hljs-function"><span class="hljs-params">friend</span> =&gt;</span> (<br>            &lt;option key=&#123;friend.id&#125; value=&#123;friend.id&#125;&gt;<br>              &#123;friend.name&#125;<br>            &lt;/option&gt;<br>          ))<br>        &#125;<br>      &lt;/select&gt;<br>    &lt;/&gt;<br>  )<br>&#125;<br></code></pre></div></td></tr></table></figure><p>我们将当前选择的好友 ID 保存在 recipientID 状态变量中，并会在用户从 &lt;select&gt; 中选择其他好友时更新这个 state。</p><p>由于 useState 会提供 recipientID 状态变量的最新值，可以将它作为参数传递给自定义的 useFriendStatus Hook。当我们选择不同的好友并更新 recipientID 状态变量时，useFriendStatus Hook 会取消订阅之前选中的好友，并订阅新选中的好友状态。</p><h1 id="Hook-规则"><a href="#Hook-规则" class="headerlink" title="Hook 规则"></a>Hook 规则</h1><h1 id="额外的-Hook"><a href="#额外的-Hook" class="headerlink" title="额外的 Hook"></a>额外的 Hook</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.im/post/6844903814349193229">https://juejin.im/post/6844903814349193229</a></li><li><a href="https://juejin.im/post/6844903985338400782">https://juejin.im/post/6844903985338400782</a></li><li><a href="https://www.ruanyifeng.com/blog/2019/09/react-hooks.html">https://www.ruanyifeng.com/blog/2019/09/react-hooks.html</a></li><li><a href="https://zh-hans.reactjs.org/docs/hooks-intro.html">https://zh-hans.reactjs.org/docs/hooks-intro.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 内存区域</title>
    <link href="/posts/74b8cfc8/"/>
    <url>/posts/74b8cfc8/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Hystrix 服务容错</title>
    <link href="/posts/1f248637/"/>
    <url>/posts/1f248637/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Cloud-Hystrix"><a href="#Spring-Cloud-Hystrix" class="headerlink" title="Spring Cloud Hystrix"></a>Spring Cloud Hystrix</h1><p>在微服务架构中，我们将系统拆分成了一个个的服务单元，各单元应用间通过服务注册与订阅的方式互相依赖。由于每个单元都在不同的进程中运行，如果某个服务不可用，可能导致级联故障，造成整个系统不可用的情况（雪崩效应）。为了解决这样的问题，产生了断路器等一系列的服务保护机制。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Spring Cloud Hystrix，它是一个基于 Netflix 的开源框架，具有如下功能：</p><ul><li>服务降级</li><li>依赖隔离</li><li>服务熔断</li><li>监控（Hystrix Dashboard）</li></ul><h1 id="实现一个-Hystrix-Server"><a href="#实现一个-Hystrix-Server" class="headerlink" title="实现一个 Hystrix Server"></a>实现一个 Hystrix Server</h1><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="添加注解"><a href="#添加注解" class="headerlink" title="添加注解"></a>添加注解</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@EnableCircuitBreaker</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HystrixApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(HystrixApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">hystrix-server</span><br><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">serviceUrl:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8761/eureka/</span><br></code></pre></div></td></tr></table></figure><h1 id="Hystrix-应用"><a href="#Hystrix-应用" class="headerlink" title="Hystrix 应用"></a>Hystrix 应用</h1><h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p>假设现在有一个接口 <code>/user/&#123;id&#125;</code> 获取用户信息。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ResultVo&lt;UserInfo&gt; <span class="hljs-title">getUserInfo</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String id)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> userService.getUserInfo(id);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在 UserService 中添加调用方法的服务降级。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@HystrixCommand(fallbackMethod = &quot;userFallback&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ResultVo&lt;UserInfo&gt; <span class="hljs-title">getUserInfo</span><span class="hljs-params">(String id)</span> </span>&#123;<br>    <span class="hljs-comment">// 正常的服务调用和业务  此处以 restTemplate 为例</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> restTemplate.getForObject(url + <span class="hljs-string">&quot;/user/&#123;1&#125;&quot;</span>, ResultVo.class, id);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> ResultVo&lt;UserInfo&gt; <span class="hljs-title">userFallback</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">// 处理服务降级需要返回的内容</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="服务降级-OpenFiegn"><a href="#服务降级-OpenFiegn" class="headerlink" title="服务降级 OpenFiegn"></a>服务降级 OpenFiegn</h2><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">hystrix:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure><h3 id="OpenFeign-Client-端实现"><a href="#OpenFeign-Client-端实现" class="headerlink" title="OpenFeign Client 端实现"></a>OpenFeign Client 端实现</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(</span><br><span class="hljs-meta">    name = &quot;user&quot;,  // 远程服务名</span><br><span class="hljs-meta">    fallback = UserClientFallback.class  // 指定 当服务降级时，采用的方法</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserClient</span> </span>&#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function">ResultVo&lt;UserInfo&gt; <span class="hljs-title">getUserInfo</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String id)</span></span>;<br><br>&#125;<br><br>---<br><br><span class="hljs-comment">// 实现 UserClient 接口</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserClientFallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserClient</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function">ResultVo&lt;UserInfo&gt; <span class="hljs-title">getUserInfo</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String id)</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// 实现降级内容</span><br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="依赖隔离"><a href="#依赖隔离" class="headerlink" title="依赖隔离"></a>依赖隔离</h2><p>SpringCloud Hystrix 的 依赖隔离 类似于docker的“舱壁模式”。<br>docker通过”舱壁模式”实现进程隔离，使得容器之间互不影响。<br>而Hystrix使用该模式实现：“线程池隔离”，会为每一个HystrixCommand创建一个独立线程池，这样就算某个在Hystrix包装下的依赖服务出现延迟过高情况，也只是对该依赖服务的调用产生影响，并不会拖慢其他服务。</p><p>使用 @HystrixCommand 来将某个函数包装成了 Hystrix 命令时，Hystrix框架自动地为这个函数实现了依赖隔离。所以依赖隔离，服务降级在使用时候都是一体化实现的，这样就可以实现服务容错保护。在编程模型上就会非常方便。</p><h2 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h2>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Zuul 服务网关</title>
    <link href="/posts/b51855cc/"/>
    <url>/posts/b51855cc/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Cloud-Zuul"><a href="#Spring-Cloud-Zuul" class="headerlink" title="Spring Cloud Zuul"></a>Spring Cloud Zuul</h1><p>在微服务架构中，后端服务往往不直接开放给调用端，而是通过一个API网关根据请求的url，路由到相应的服务。<br>当添加API网关后，在第三方调用端和服务提供方之间就创建了一面墙，这面墙直接与调用方通信进行权限控制，后将请求均衡分发给后台服务端。<br>Spring Cloud Zuul 是一个基于JVM路由和服务端的负载均衡器，提供动态路由，监控，弹性，安全等的边缘服务。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Zuul 的主要功能是路由转发和过滤器（Filter）。不同类型的 Filter 用于处理请求，可以实现以下功能：</p><ul><li>权限控制和安全性：可以识别认证需要的信息和拒绝不满足条件的请求</li><li>监控：监控请求信息</li><li>动态路由：根据需要动态地路由请求到后台的不同服务集群</li><li>压力测试：逐渐增大到集群的流量，以便进行性能评估</li><li>负载均衡：为每种类型的请求分配容量并丢弃超过限额的请求</li><li>限流</li><li>黑白名单过滤</li><li>静态资源处理：直接在zuul处理静态资源的响应而不需要转发这些请求到内部集群中</li></ul><h1 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h1><h2 id="创建一个-api-gateway"><a href="#创建一个-api-gateway" class="headerlink" title="创建一个 api-gateway"></a>创建一个 api-gateway</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zuul<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="添加注解"><a href="#添加注解" class="headerlink" title="添加注解"></a>添加注解</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@EnableZuulProxy</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiGatewayApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(ApiGatewayApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">api-gateway</span><br><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9000</span><br><br><span class="hljs-comment"># 自定义路由规则</span><br><span class="hljs-attr">zuul:</span><br>  <span class="hljs-attr">routes:</span><br>    <span class="hljs-attr">user:</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">/user/**</span><br>      <span class="hljs-attr">serviceId:</span> <span class="hljs-string">user</span> <br></code></pre></div></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>通过以上配置文件配置，即可通过 api-gateway 服务去请求 user 服务。</p><p>假设 user 服务的端口为 8080，其中包含一个 api 为 <code>/info</code>。<br>通过访问 <code>http://localhost:9000/user/info</code>，即可访问该 api。（若原接口包含路由前缀 /user，需要使用 /user/user/info 访问）</p><h2 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h2><h3 id="统一前缀"><a href="#统一前缀" class="headerlink" title="统一前缀"></a>统一前缀</h3><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">zuul:</span><br>  <span class="hljs-attr">prefix:</span> <span class="hljs-string">/proxy</span><br></code></pre></div></td></tr></table></figure><h3 id="Header-过滤及重定向添加-Host"><a href="#Header-过滤及重定向添加-Host" class="headerlink" title="Header 过滤及重定向添加 Host"></a>Header 过滤及重定向添加 Host</h3><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">zuul:</span><br>  <span class="hljs-comment"># 默认为该配置，会过滤 Cookie Set-Cookie Authorization 信息</span><br>  <span class="hljs-comment"># 设置为空即不会过滤</span><br>  <span class="hljs-attr">sensitive-headers:</span> <span class="hljs-string">Cookie,Set-Cookie,Authorization</span><br><br><span class="hljs-meta">--- </span><br><br><span class="hljs-attr">zuul:</span><br>  <span class="hljs-attr">add-host-header:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 重定向会添加 host 请求头</span><br></code></pre></div></td></tr></table></figure><h2 id="查看路由信息"><a href="#查看路由信息" class="headerlink" title="查看路由信息"></a>查看路由信息</h2><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9000</span><br><br><span class="hljs-attr">management:</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&#x27;routes&#x27;</span><br></code></pre></div></td></tr></table></figure><h3 id="访问接口"><a href="#访问接口" class="headerlink" title="访问接口"></a>访问接口</h3><ul><li>访问 <code>http://localhost:9000/actuator/routes</code> 获取信息</li><li>访问 <code>http://localhost:9000/actuator/routes/details</code> 获取详细信息</li></ul><h1 id="Zuul-应用"><a href="#Zuul-应用" class="headerlink" title="Zuul 应用"></a>Zuul 应用</h1><h2 id="Zuul-Filter"><a href="#Zuul-Filter" class="headerlink" title="Zuul Filter"></a>Zuul Filter</h2><p>Filter是Zuul的核心，用来实现对外服务的控制。Filter有4个生命周期。</p><ul><li>pre<ul><li>在请求被路由到目标服务前执行。</li><li>比如权限校验、打印日志等功能。</li></ul></li><li>routing<ul><li>在请求被路由到目标服务时执行。</li><li>用于构建发送给微服务的请求，并使用 Apache HttpClient 或 Netfilx Ribbon 请求微服务。</li></ul></li><li>post<ul><li>这种过滤器在路由到微服务以后执行。</li><li>为响应添加标准的HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。</li></ul></li><li>error<ul><li>其他阶段发生错误时执行该过滤器。</li></ul></li></ul><p><img src="https://source.letitout.cloud/images/articles/2020/07/spring-cloud/zuul-core.png" alt="zuul-core"></p><h3 id="自定义-Filter"><a href="#自定义-Filter" class="headerlink" title="自定义 Filter"></a>自定义 Filter</h3><p>实现自定义 Filter，需继承 <code>com.netflix.zuul.ZuulFilter</code>，并覆盖继承的方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ZuulFilter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function">String <span class="hljs-title">filterType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 定义filter的类型，pre、route、post、error</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">filterOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 定义filter的顺序，数字越小表示顺序越高，越先执行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 是否需要执行该filter，true表示执行，false表示不执行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function">Object <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// filter需要执行的具体操作</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Zuul-限流"><a href="#Zuul-限流" class="headerlink" title="Zuul 限流"></a>Zuul 限流</h3><p>限流在前置过滤器（pre）前使用，在请求被转发前调用，且优先级最高。</p><p>令牌桶限流示例。令牌桶算法能够在限制数据的平均传输速率的同时还允许某种程度的突发传输。</p><p>令牌桶算法会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。</p><p><img src="https://source.letitout.cloud/images/articles/2020/07/spring-cloud/token-bucket.png" alt="token-bucket"></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.cloud.netflix.zuul.filters.support.FilterConstants;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RateLimiterFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ZuulFilter</span> </span>&#123;<br>    <span class="hljs-comment">// 直接使用 guava 中的 RateLimiter 实现</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> RateLimiter RATE_LIMITER = RateLimiter.create(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">filterType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> FilterConstants.PRE_TYPE;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">filterOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 限流是最高优先级，所以比最高优先级 -3 还要小</span><br>        <span class="hljs-keyword">return</span> FilterConstants.SERVLET_DETECTION_FILTER_ORDER - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ZuulException </span>&#123;<br>        <span class="hljs-comment">// 如果没有拿到令牌</span><br>        <span class="hljs-keyword">if</span> (!RATE_LIMITER.tryAcquire()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="Zuul-鉴权"><a href="#Zuul-鉴权" class="headerlink" title="Zuul 鉴权"></a>Zuul 鉴权</h3><p>在请求服务前，判断是否有权限访问。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TokenFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ZuulFilter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">filterType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> FilterConstants.PRE_TYPE;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">filterOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 越小越靠前，放在 PRE_DECORATION_FILTER_ORDER 之前</span><br>        <span class="hljs-keyword">return</span> PRE_DECORATION_FILTER_ORDER - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 需要定义的逻辑</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ZuulException </span>&#123;<br>        RequestContext requestContext = RequestContext.getCurrentContext();<br>        HttpServletRequest request = requestContext.getRequest();<br><br>        <span class="hljs-comment">// 需要根据实际情况，从 header / cookie 中获取信息</span><br>        String token = ...;<br>        <span class="hljs-comment">// 根据实际情况进行校验</span><br>        <span class="hljs-keyword">if</span> (...) &#123;<br>            <span class="hljs-comment">// 首先设置 zuul</span><br>            requestContext.setSendZuulResponse(<span class="hljs-keyword">false</span>);<br>            <span class="hljs-comment">// 设置返回信息</span><br>            requestContext.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="Zuul-跨域"><a href="#Zuul-跨域" class="headerlink" title="Zuul 跨域"></a>Zuul 跨域</h2><p>在浏览器中的 ajax 请求是有同源策略的，如果违反了同源策略，就会有跨域问题。在 Zuul 中添加 CorsFilter 过滤器，是跨域问题的一种解决方案。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CorsConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CorsFilter <span class="hljs-title">corsFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> UrlBaseCorsConfigurationSource source = <span class="hljs-keyword">new</span> UrlBaseCorsConfigrationSOurce();<br>        <span class="hljs-keyword">final</span> CorsConfiguration config = <span class="hljs-keyword">new</span> CorsConfiguration();<br><br>        config.setAllowCredentials(<span class="hljs-keyword">true</span>);<br>        config.setAllowedOrigins(Collections.singletonList(<span class="hljs-string">&quot;*&quot;</span>));<br>        config.setAllowedHeaders(Collections.singletonList(<span class="hljs-string">&quot;*&quot;</span>))；<br>        config.setAllowedMethods(Collections.singletonList(<span class="hljs-string">&quot;*&quot;</span>));<br>        config.setMaxAge(<span class="hljs-number">300L</span>);<br><br>        source.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>, config);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CorsFilter(source);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Config 统一配置中心</title>
    <link href="/posts/505de307/"/>
    <url>/posts/505de307/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h1><p>Spring Cloud Config 是一个解决分布式系统的配置管理方案。</p><ul><li>Server<ul><li>提供配置文件的存储，以接口的形式提供配置文件的内容</li></ul></li><li>Client<ul><li>通过接口获取数据，并依据此数据初始化应用</li></ul></li></ul><h1 id="Config-Server"><a href="#Config-Server" class="headerlink" title="Config Server"></a>Config Server</h1><h2 id="新建一个-git-仓库"><a href="#新建一个-git-仓库" class="headerlink" title="新建一个 git 仓库"></a>新建一个 git 仓库</h2><p>在 git 服务器上创建一个仓库，用来存放配置文件。</p><p>并在仓库中添加相应的配置文件。</p><ul><li>user-dev.yml</li><li>user-test.yml</li><li>user-prod.yml</li></ul><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="添加注解"><a href="#添加注解" class="headerlink" title="添加注解"></a>添加注解</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@EnableConfigServer</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigApplication</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>SpringApplication.run(ConfigApplication.class, args);<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">config</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">server:</span><br>        <span class="hljs-attr">git:</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">http://github.com/xxx/confg</span>  <span class="hljs-comment"># 配置文件仓库地址</span><br>          <span class="hljs-attr">username:</span> <span class="hljs-string">...</span><br>          <span class="hljs-attr">password:</span> <span class="hljs-string">...</span><br>          <span class="hljs-attr">searchpath:</span> <span class="hljs-string">config-repo</span>  <span class="hljs-comment"># git仓库地址下的相对地址，可配置多个</span><br><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8000</span><br><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">serviceUrl:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8761/eureka/</span><br></code></pre></div></td></tr></table></figure><h3 id="通过接口查看配置"><a href="#通过接口查看配置" class="headerlink" title="通过接口查看配置"></a>通过接口查看配置</h3><p>仓库中的配置文件会被转换成web接口，启动应用后，可在浏览器中查看配置文件（若配置文件的格式有错误，将无法访问）。</p><p>如访问 <code>http://localhost:8000/user/dev</code> 即可返回 user-dev.yml 的配置信息。</p><ul><li><code>/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]</code></li><li><code>/&#123;application&#125;-&#123;profile&#125;.yml</code></li><li><code>/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml</code></li></ul><p>profile：配置环境，label：仓库分支。</p><h1 id="Config-Client"><a href="#Config-Client" class="headerlink" title="Config Client"></a>Config Client</h1><h2 id="在项目中创建-bootstrap-yml"><a href="#在项目中创建-bootstrap-yml" class="headerlink" title="在项目中创建 bootstrap.yml"></a>在项目中创建 bootstrap.yml</h2><p>在项目中，bootstrap.yml 会优先于 application.yml 加载。</p><h3 id="application-yml-应用场景"><a href="#application-yml-应用场景" class="headerlink" title="application.yml 应用场景"></a>application.yml 应用场景</h3><p>主要用于 Spring Boot 项目的自动化配置。</p><h3 id="bootstrap-yml-应用场景"><a href="#bootstrap-yml-应用场景" class="headerlink" title="bootstrap.yml 应用场景"></a>bootstrap.yml 应用场景</h3><ul><li>从额外的资源加载配置信息（如使用 Spring Cloud Config 时）</li><li>一些固定不能被覆盖的属性（具有高优先级，一般不会被本地配置或application中同名配置覆盖）</li><li>一些 加密/解密 的场景</li></ul><h2 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">user</span>  <span class="hljs-comment"># 该应用获取之前配置好的 user-dev.yml </span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">http://localhost:8000/</span><br>      <span class="hljs-attr">profile:</span> <span class="hljs-string">dev</span><br>      <span class="hljs-attr">label:</span> <span class="hljs-string">master</span><br><br><span class="hljs-meta">---</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 启用服务发现 (Eureka)</span><br>        <span class="hljs-attr">service-id:</span> <span class="hljs-string">config</span>  <span class="hljs-comment"># spring cloud config server 应用名称</span><br>      <span class="hljs-attr">profile:</span> <span class="hljs-string">dev</span><br>      <span class="hljs-attr">label:</span> <span class="hljs-string">master</span><br></code></pre></div></td></tr></table></figure><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>启动服务时，即会先去 git 仓库获取配置信息。</p><h1 id="配置信息自动更新"><a href="#配置信息自动更新" class="headerlink" title="配置信息自动更新"></a>配置信息自动更新</h1><p>当 git 仓库中的配置信息更新后，使用配置的客户端并不会自动更新配置。所以我们需要一些机制去触发配置的更新。</p><h2 id="actuator"><a href="#actuator" class="headerlink" title="actuator"></a>actuator</h2><h3 id="添加依赖-2"><a href="#添加依赖-2" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="添加注解，打开更新机制"><a href="#添加注解，打开更新机制" class="headerlink" title="添加注解，打开更新机制"></a>添加注解，打开更新机制</h3><p>通过在需要加载更新配置的类上添加 <code>@RefreshScope</code>，当客户端通过触发 POST 方式的 <code>/refresh</code> 时，会自动将新的配置更新到相应的字段中。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@RefreshScope</span>  <span class="hljs-comment">// 该类中配置相关会自动刷新</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActuatorController</span> </span>&#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;env&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String env;<br>    <span class="hljs-meta">@RequestMapping(&quot;/env&quot;)</span><br>    <span class="hljs-keyword">public</span> String env &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.env;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="配置文件-2"><a href="#配置文件-2" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-comment"># server 端添加</span><br><span class="hljs-attr">management:</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">&quot;*&quot;</span><br><br><span class="hljs-meta">---</span><br><br><span class="hljs-comment"># client 端添加</span><br><span class="hljs-attr">management:</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">refresh</span><br></code></pre></div></td></tr></table></figure><h3 id="测试自动刷新"><a href="#测试自动刷新" class="headerlink" title="测试自动刷新"></a>测试自动刷新</h3><p>当 git 仓库中配置文件更新后，通过发送 POST 请求到 <code>/refresh</code> 后，客户端会自动获取最新配置。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">curl -v -X POST http://localhost:8080/actuator/refresh<br></code></pre></div></td></tr></table></figure><h2 id="Spring-Cloud-Bus-（推荐）"><a href="#Spring-Cloud-Bus-（推荐）" class="headerlink" title="Spring Cloud Bus （推荐）"></a>Spring Cloud Bus （推荐）</h2><p>通过 spring cloud bus，通过 POST 请求 <code>/bus-refresh</code>，实现自动获取最新配置。</p><p>至此两种消息代理：</p><ul><li>RabbitMQ</li><li>Kafka</li></ul><h2 id="WebHook"><a href="#WebHook" class="headerlink" title="WebHook"></a>WebHook</h2><p>WebHook 是当某个事件发生时，通过发送 http post 请求的方式来通知信息接收方。</p><p>通过创建 WebHook 即可自动触发 POST 请求，让客户端动态刷新配置。</p>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud 服务通信</title>
    <link href="/posts/df4cbf58/"/>
    <url>/posts/df4cbf58/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Cloud-服务通信"><a href="#Spring-Cloud-服务通信" class="headerlink" title="Spring Cloud 服务通信"></a>Spring Cloud 服务通信</h1><ul><li><p>同步通信：</p><ul><li>dobbo 通过 RPC 远程调用。</li><li>spring cloud 通过 REST 接口调用。</li></ul></li><li><p>异步通信：</p><ul><li>通过消息对列，如：RabbitMQ，Kafka，ActiveM 等。</li></ul></li></ul><p>本文主要介绍 Spring Cloud 使用 RestTemplate / OpenFeign 进行 REST 接口调用。</p><h1 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h1><h2 id="通过-RestTemplate-进行调用"><a href="#通过-RestTemplate-进行调用" class="headerlink" title="通过 RestTemplate 进行调用"></a>通过 RestTemplate 进行调用</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ProductInfo <span class="hljs-title">getProductMsg</span><span class="hljs-params">(String id)</span> </span>&#123;<br>    RestTemplate restTemplate = <span class="hljs-keyword">new</span> RestTemplate();<br>    ProductInfo response = restTemplate.getForObject(<br>        <span class="hljs-string">&quot;http://example.com/product/info&quot;</span>,    <span class="hljs-comment">// 远程调用地址</span><br>        ProductInfo.class,                    <span class="hljs-comment">// response 类型</span><br>        id                                    <span class="hljs-comment">// 需要传递的参数</span><br>    );<br>    <span class="hljs-keyword">return</span> response;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="利用-LoadBalancerClient-获取信息"><a href="#利用-LoadBalancerClient-获取信息" class="headerlink" title="利用 LoadBalancerClient 获取信息"></a>利用 LoadBalancerClient 获取信息</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> LoadBalancerClient loadBalancerClient;<br><span class="hljs-function"><span class="hljs-keyword">public</span> ProductInfo <span class="hljs-title">getProductMsg</span><span class="hljs-params">(String id)</span> </span>&#123; <br>    RestTemplate restTemplate = <span class="hljs-keyword">new</span> RestTemplate();<br>    ServiceInstance serviceInstance = loadBalancerClient.choose(<span class="hljs-string">&quot;PRODUCT&quot;</span>);<br><br>    <span class="hljs-comment">// 利用 loadBalancerClient 通过应用名（spring.application.name）获取信息</span><br>    String url = String.format(<span class="hljs-string">&quot;http://%s:%s&quot;</span>, serviceInstance.getHost(), serviceInstance.getPort()) + <span class="hljs-string">&quot;/product/info&quot;</span>;<br><br>    ProductInfo response = restTemplate.getForObject(url, ProductInfo.class, id);<br>    <span class="hljs-keyword">return</span> response;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="利用-LoadBalance-在-RestTemplate-中直接使用应用名称"><a href="#利用-LoadBalance-在-RestTemplate-中直接使用应用名称" class="headerlink" title="利用 LoadBalance 在 RestTemplate 中直接使用应用名称"></a>利用 LoadBalance 在 RestTemplate 中直接使用应用名称</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestTemplateConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalance</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>    &#125;<br>&#125;<br><br>---<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><span class="hljs-function"><span class="hljs-keyword">public</span> ProductInfo <span class="hljs-title">getProductMsg</span><span class="hljs-params">(String id)</span> </span>&#123;<br>    <span class="hljs-comment">// 利用 @LoadBalance 可以在 RestTemplate 中使用应用名称</span><br>    ProductInfo response = restTemplate.getForObject(<span class="hljs-string">&quot;http://PRODUCT/product/msg&quot;</span>, ProductInfo.class, id);<br>    <span class="hljs-keyword">return</span> response;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="OpenFeign-（推荐）"><a href="#OpenFeign-（推荐）" class="headerlink" title="OpenFeign （推荐）"></a>OpenFeign （推荐）</h1><h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="添加启动注解"><a href="#添加启动注解" class="headerlink" title="添加启动注解"></a>添加启动注解</h2><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;<br><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(FeignApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>现在有两个服务，分别为 Prodcut 和 Order 。<br>需求： Order 服务中，客户进行了下单操作后，调用 Product（Feign） 的进行减库存操作。</p><ul><li>Product 服务中，定义远程调用端。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecreaseStockInput</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br>---<br><br><span class="hljs-meta">@FeignClient(name = &quot;product&quot;)</span>  <span class="hljs-comment">// name: 远程服务名(Spring.application.name)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ProductClient</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/product/decrease_stock&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decreaseStock</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> List&lt;DecreaseStockInput&gt; decreaseStockInputList)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>Order 服务中，对 Product Client 进行调用。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;<br>    <span class="hljs-comment">// 注入的为 Product 中的 ProductClient</span><br>    <span class="hljs-comment">// 通过依赖的方式</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ProductClient productClient;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OrderDTO <span class="hljs-title">create</span><span class="hljs-params">(OrderDTO orderDTO)</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// 调用 Product 服务中的 api 进行减库存操作</span><br>        productClient.decreaseStock(decreaseStockInputList);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Eureka 服务注册与发现</title>
    <link href="/posts/d0c4b192/"/>
    <url>/posts/d0c4b192/</url>
    
    <content type="html"><![CDATA[<h1 id="Eureka-找到啦！"><a href="#Eureka-找到啦！" class="headerlink" title="Eureka 找到啦！"></a>Eureka 找到啦！</h1><p>服务注册与发现</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务注册和发现。采用了 C-S 的设计架构。用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。</li><li>由两个组件组成。<ul><li>Ereka Server。 注册中心</li><li>Ereka Client。 服务注册</li></ul></li></ul><p>Eureka 采用了<strong>客户端发现</strong>的方式，在服务运行时，通过(轮训、hash等负载均衡机制等方式)注册中心找到需要服务（即 A 通过 注册中心 找 B，需要谁找谁）。</p><p><img src="https://source.letitout.cloud/images/articles/2020/07/spring-cloud/eureka-server-discovery.png" alt="eureka-server-discovery"></p><h1 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h1><p>注册中心记录着所有应用的信息和状态(如：应用名，所在服务器，是否正常工作)。</p><h2 id="实现一个注册中心"><a href="#实现一个注册中心" class="headerlink" title="实现一个注册中心"></a>实现一个注册中心</h2><h3 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <br></code></pre></div></td></tr></table></figure><h3 id="2-添加启动注解"><a href="#2-添加启动注解" class="headerlink" title="2. 添加启动注解"></a>2. 添加启动注解</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@EnableEurekaServer</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaServerApplication</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>SpringApplication.run(EurekaServerApplication.class, args);<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-配置文件"><a href="#3-配置文件" class="headerlink" title="3. 配置文件"></a>3. 配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span><br><br><span class="hljs-attr">Server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8761</span><br><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 是否将自己注册到Eureka Server，作为 Server 端不需要</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 是否从Eureka Server获取注册信息，作为 Server 端不需要</span><br>    <span class="hljs-attr">service-url:</span>  <span class="hljs-comment"># 接收的是一个 Map 结构</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8761/eureka/</span><br></code></pre></div></td></tr></table></figure><h3 id="4-启动程序"><a href="#4-启动程序" class="headerlink" title="4. 启动程序"></a>4. 启动程序</h3><p>启动后，访问 <a href="http://localhost:8761/%EF%BC%8C%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0">http://localhost:8761/，即可看到</a> Spring Eureka 界面。</p><h2 id="实现-Eureka-集群"><a href="#实现-Eureka-集群" class="headerlink" title="实现 Eureka 集群"></a>实现 Eureka 集群</h2><p>在一个分布式系统中，服务注册中心是最重要的基础部分，理应随时处于可以提供服务的状态。为了维持其可用性，通常会采用集群的方案。Eureka通过<strong>互相注册</strong>的方式来实现高可用的部署</p><h3 id="双节点注册"><a href="#双节点注册" class="headerlink" title="双节点注册"></a>双节点注册</h3><p>创建两台服务器，端口分别为 8761 和 8762。</p><p>将 8761 的服务器配置指向 8761，将 8762 的服务器指向 8761。</p><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span><br><span class="hljs-attr">Server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8761</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">service-url:</span>  <span class="hljs-comment"># 将 service-url 指向 8762</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8762/eureka/</span><br><br><span class="hljs-meta">---</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span><br><span class="hljs-attr">Server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8762</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">service-url:</span>  <span class="hljs-comment"># 将 service-url 指向 8761</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8761/eureka/</span><br></code></pre></div></td></tr></table></figure><p>启动程序后，通过 <a href="http://localhost:8761/">http://localhost:8761/</a> 和 <a href="http://localhost:8762/">http://localhost:8762/</a> 都可访问 Eureka 界面。并且可以看到另一个节点信息节点的信息。</p><p><img src="https://source.letitout.cloud/images/articles/2020/07/spring-cloud/eureka-server-cluster-1.png" alt="eureka-server-cluster-1"></p><p><img src="https://source.letitout.cloud/images/articles/2020/07/spring-cloud/eureka-server-cluster-2.png" alt="eureka-server-cluster-2"></p><h3 id="多节点注册"><a href="#多节点注册" class="headerlink" title="多节点注册"></a>多节点注册</h3><p>在生产中我们需要三台或者大于三台的注册中心来保证服务的稳定性，配置的原理其实都一样：将注册中心分别指向其它的注册中心。</p><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-meta">---</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8761</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">serviceUrl:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8762/eureka/,http://localhost:8763/eureka/</span><br><br><span class="hljs-meta">---</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8762</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">serviceUrl:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8761/eureka/,http://localhost:8763/eureka/</span><br><br><span class="hljs-meta">---</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8763</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">serviceUrl:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8761/eureka/,http://localhost:8762/eureka/</span><br></code></pre></div></td></tr></table></figure><h1 id="Eureka-Client"><a href="#Eureka-Client" class="headerlink" title="Eureka Client"></a>Eureka Client</h1><h2 id="实现一个服务注册"><a href="#实现一个服务注册" class="headerlink" title="实现一个服务注册"></a>实现一个服务注册</h2><h3 id="1-依赖配置"><a href="#1-依赖配置" class="headerlink" title="1. 依赖配置"></a>1. 依赖配置</h3><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="2-添加启动注解-1"><a href="#2-添加启动注解-1" class="headerlink" title="2. 添加启动注解"></a>2. 添加启动注解</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;<br><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClientApplication</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>SpringApplication.run(ClientApplication.class, args);<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-配置文件-1"><a href="#3-配置文件-1" class="headerlink" title="3. 配置文件"></a>3. 配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-client</span><br><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">serviceUrl:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8761/eureka/</span><br><span class="hljs-comment"># instance:  # 自定义链接</span><br><span class="hljs-comment">#   hostname: example.com</span><br></code></pre></div></td></tr></table></figure><h3 id="4-启动程序-1"><a href="#4-启动程序-1" class="headerlink" title="4. 启动程序"></a>4. 启动程序</h3><p>启动程序后，进入 Eureka 页面 <a href="http://localhost:8761/eureka/%EF%BC%8C%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E6%B3%A8%E5%86%8C%E7%9A%84%E6%9C%8D%E5%8A%A1">http://localhost:8761/eureka/，即可看到注册的服务</a> eureka-client。</p><p><img src="https://source.letitout.cloud/images/articles/2020/07/spring-cloud/eureka-client.png" alt="eureka-client"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>分布式系统中，服务注册中心是最重要的基础部分</li><li>@EnableEurekaServer  @EnableEurekaClient</li><li>具有 心跳检测，健康检查，负载均衡等功能</li><li>为保证高可用，建议集群部署</li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>雷蛇 灵刃 15 黑苹果</title>
    <link href="/posts/4b8633b7/"/>
    <url>/posts/4b8633b7/</url>
    
    <content type="html"><![CDATA[<h1 id="雷蛇灵刃-15-标准版-黑苹果"><a href="#雷蛇灵刃-15-标准版-黑苹果" class="headerlink" title="雷蛇灵刃 15 标准版 黑苹果"></a>雷蛇灵刃 15 标准版 黑苹果</h1><p><strong>警告：该教程仅为个人记录，该笔记本安装涉及解锁BIOS，存在一定风险，如您使用该教程对计算机进行更改，所造成的的任何后果我概不负责。</strong></p><h1 id="写在最前"><a href="#写在最前" class="headerlink" title="写在最前"></a>写在最前</h1><ul><li><p>因为疫情原因春节一直宅在家，学校假期也延长了，找到了同款笔记本的教程，所以入坑安装黑苹果，最近把步骤整理了一下。</p></li><li><p>为什么买了这个笔记本？我的旧笔记本是 i5-7200U 的双核低压，内存也只有板载的 8G 不能拓展，性能捉急还经常爆内存。本来的打算再凑点钱买乞丐版的 XPS15 无显卡版（i5-9750H + 8G）。无意中看到了雷蛇灵刃15标准版的旧款在清仓（i7-8750H + 1060Max-Q + 16G），价钱比XPS丐版便宜不少还多个显卡和8G内存，我对显卡要求不大，Intel 挤牙膏CPU只是频率上低 0.1GHZ。</p></li><li><p>使用感受：这是我第一个雷蛇的产品，外观真的很好看，我没有雷蛇信仰，灯什么的无所谓。下一次买笔记本还是要买大众一点的，冷门笔记本在驱动方面的确有点小问题，windows重装之后插耳机经常无法切换，在Linux（试了下 Ubuntu 和 Manjaro）下，都不能识别到耳机。了解的话希望能帮助一下，感谢。</p></li><li><p>安装过程我主要参考了 <a href="https://www.tonymacx86.com/threads/guide-razer-blade-15-2018-detailed-install-guide-high-sierra-10-13-6-17g2208-17g5019.264017/">这篇</a> 和 <a href="https://github.com/stonevil/Razer_Blade_Advanced_early_2019_Hackintosh">这篇</a> 教程，感谢他们的辛苦付出。部分内容为他们所写教程的汉化，详细或精简，我的水平有限，刚接触黑苹果，建议同时参考他们的教程。</p></li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><strong>文件下载:</strong> <a href="https://github.com/EmeryWan/Razer-Blade-15-2018-Base-Hackintosh">https://github.com/EmeryWan/Razer-Blade-15-2018-Base-Hackintosh</a></p><ul><li>硬件介绍</li><li>结果介绍</li><li>解锁BIOS</li><li>安装前准备</li><li>系统安装</li><li>DSDT，SSDT制作</li><li>网卡</li><li>一些优化</li></ul><h2 id="1-硬件介绍"><a href="#1-硬件介绍" class="headerlink" title="[1] 硬件介绍"></a>[1] 硬件介绍</h2><table><thead><tr><th align="center"></th><th align="center">型号</th><th align="center">最终情况</th></tr></thead><tbody><tr><td align="center">CPU</td><td align="center">i7-8750H</td><td align="center">可用</td></tr><tr><td align="center">GPU</td><td align="center">Nvdia 1060 Max-Q</td><td align="center">除 10.13 High Sierra 安装 WebDriver 外不可用</td></tr><tr><td align="center">硬盘</td><td align="center">更换了 金士顿 A2000</td><td align="center">可用</td></tr><tr><td align="center">网卡</td><td align="center">9560NGW</td><td align="center">WIFI 目前无解，蓝牙可用</td></tr><tr><td align="center">显示器</td><td align="center">1080P</td><td align="center">可用</td></tr><tr><td align="center">摄像头</td><td align="center"></td><td align="center">可用</td></tr><tr><td align="center">扬声器</td><td align="center"></td><td align="center">可用</td></tr><tr><td align="center">耳机</td><td align="center"></td><td align="center">无法检测到麦克风，需要手动切换</td></tr><tr><td align="center">麦克风</td><td align="center"></td><td align="center">不可用，已识别，但在设置中未看见输入电平</td></tr><tr><td align="center">触控板</td><td align="center"></td><td align="center">手势可用（反应稍慢）</td></tr><tr><td align="center">HDMI 接口</td><td align="center"></td><td align="center">直通显卡，除安装 High Sierra 外不可用</td></tr><tr><td align="center">Mini DP 接口</td><td align="center"></td><td align="center">直通显卡，除安装 High Sierra 外不可用</td></tr><tr><td align="center">雷电3</td><td align="center"></td><td align="center">可热插拔，被识别成 USB3.1，可外接拓展坞外接显示器</td></tr></tbody></table><h2 id="2-安装结果"><a href="#2-安装结果" class="headerlink" title="[2] 安装结果"></a>[2] 安装结果</h2><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/2-1.png" alt="2-1"></p><figure class="highlight txt"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs txt">.<br>├── CLOVERX64.efi<br>├── config.plist<br>├── ACPI<br>│   └── patched<br>│       ├── DSDT.aml<br>│       ├── SSDT-10-OptTabl.aml<br>│       ├── SSDT-PNLF.aml<br>│       ├── SSDT-UIAC-ALL.aml<br>│       ├── SSDT-USBX.aml<br>│       └── SSDT-XOSI.aml<br>├── drivers<br>├── kexts<br>│   └── Other<br>│       ├── ACPIBatteryManager.kext<br>│       ├── AppleALC.kext<br>│       ├── CPUFriend.kext<br>│       ├── Lilu.kext<br>│       ├── LiluFriend.kext<br>│       ├── NoTouchID.kext<br>│       ├── RealtekRTL8111.kext<br>│       ├── SMCBatteryManager.kext<br>│       ├── SMCLightSensor.kext<br>│       ├── SMCProcessor.kext<br>│       ├── SMCSuperIO.kext<br>│       ├── VirtualSMC.kext<br>│       ├── USBInjectAll.kext<br>│       ├── VoodooI2C.kext<br>│       ├── VoodooI2CHID.kext<br>│       └── WhateverGreen.kext<br>├── misc<br>├── themes<br>└── tools<br></code></pre></div></td></tr></table></figure><h3 id="待解决问题"><a href="#待解决问题" class="headerlink" title="待解决问题"></a>待解决问题</h3><p>我也是刚刚接触黑苹果，很多问题我也无法解决，哪位好心人会解决的话，希望能教我一下，感谢。</p><ul><li><p>麦克风无法使用，系统能找到但无法使用，耳机麦克风无法找到。想要使用的话只能通过蓝牙耳机了。</p></li><li><p>输出设备默认识别到了扬声器和耳机（即使未插入耳机），无法自动切换，需手动切换。</p><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/2-2.png" alt="2-2"></p></li></ul><h2 id="3-解锁BIOS"><a href="#3-解锁BIOS" class="headerlink" title="[3] 解锁BIOS"></a>[3] 解锁BIOS</h2><p><strong>解锁BIOS，存在一定风险，如您使用该教程对计算机进行更改，所造成的的任何后果我概不负责！！！</strong></p><p>雷蛇国内官网没有提供驱动和BIOS的下载，如有需要，需要访问美国官网。<a href="https://support.razer.com/gaming-laptops/razer-blade-15-2018-base/">点我。</a></p><p>该笔记本 DVMT 预分配默认为 32MB，不足以启动 MacOS，在 BIOS 中该设置项默认隐藏，所以要提取本机 BIOS 并且进行解锁，将 DVMT 预分配默认设置为 64MB（1080P），分辨率更高请分配更大空间。</p><p><strong>建议在 windows 下操作。</strong></p><h3 id="3-1-提取本机-BIOS"><a href="#3-1-提取本机-BIOS" class="headerlink" title="[3-1] 提取本机 BIOS"></a>[3-1] 提取本机 BIOS</h3><p><strong>注意备份好。</strong></p><p>打开 <code>AFUWINGUI.exe</code>，点击 Save 按钮，导出本机当前 BIOS 。</p><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/3-1.png" alt="3-1"></p><h3 id="3-2-修改-BIOS"><a href="#3-2-修改-BIOS" class="headerlink" title="[3-2] 修改 BIOS"></a>[3-2] 修改 BIOS</h3><ul><li>打开 <code>AMIBCP.exe</code> ，点击 File -&gt; open 打开导出的 BIOS。</li><li>如图，在左侧选择 / -&gt; Setup -&gt; Chipset，将左侧的 <code>System Agent Configuration</code> 的 Access 由 Default 修改为 USER</li></ul><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/3-2.png" alt="3-2"></p><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/3-3.png" alt="3-3"></p><ul><li>修改完后点击 File -&gt; Save as。重命名为新的 BIOS。</li></ul><h3 id="3-3-刷入新-BIOS"><a href="#3-3-刷入新-BIOS" class="headerlink" title="[3-3] 刷入新 BIOS"></a>[3-3] 刷入新 BIOS</h3><p><strong>！！！ 注意，该过程虽然简单，但有一定风险，造成的任何结果与本人无关。</strong></p><ul><li><p>重新打开 AFUWINGUI.exe，点击 Open 打开刚刚修改后的 BIOS。</p><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/3-4.png" alt="3-4"></p></li><li><p>尽可能的退出其他程序，尽量保持后台干净，再点击 Flash 刷入新的 BIOS。</p></li></ul><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/3-5.png" alt="3-5"></p><ul><li>重启</li></ul><h1 id="4-安装前准备"><a href="#4-安装前准备" class="headerlink" title="[4] 安装前准备"></a>[4] 安装前准备</h1><h3 id="4-1-准备macOS-Catalina-安装盘"><a href="#4-1-准备macOS-Catalina-安装盘" class="headerlink" title="[4-1] 准备macOS Catalina 安装盘"></a>[4-1] 准备macOS Catalina 安装盘</h3><p>推荐使用<a href="https://blog.daliansky.net/">黑果小兵</a>制作的镜像，使用 <strong>TransMac</strong> 制作（软件在文件夹中已提供）。<a href="https://blog.daliansky.net/macOS-Catalina-10.15.3-19D76-Release-version-with-Clover-5103-original-image-Double-EFI-Version.html">这里是10.15.3的镜像</a>。</p><p>如果您要安装更新的系统，请升级 CLOVER，和 kexts/ 到对应兼容或更新的版本，可将制作好的安装盘中 <code>EFI/CLOVER</code> 的文件进行同名替换。（未来的新版本可能不可预知的问题，请酌情升级）。</p><h3 id="4-2-启动盘制作"><a href="#4-2-启动盘制作" class="headerlink" title="[4-2] 启动盘制作"></a>[4-2] 启动盘制作</h3><p>请参考，或自行搜索，网上教程很多。<a href="https://zhuanlan.zhihu.com/p/58630676">点我。</a></p><h2 id="5-系统安装"><a href="#5-系统安装" class="headerlink" title="[5] 系统安装"></a>[5] 系统安装</h2><h3 id="5-1-BIOS-设置"><a href="#5-1-BIOS-设置" class="headerlink" title="[5-1] BIOS 设置"></a>[5-1] BIOS 设置</h3><ul><li><p><code>Advanced</code></p><ul><li><code>Thunderbolt(TM) Configuration</code><ul><li><code>Security Level</code> 设置成 <code>No Security</code></li></ul></li></ul></li><li><p><code>Chipset</code></p><ul><li><code>System Agent (SA) Configuration</code><ul><li><code>Graphics Configuration</code><ul><li><code>DVMT Pre-Allocated</code>  设置成 <code>64</code></li><li><code>DVMT Total Gfx Mem</code>  设置成 <code>MAX</code></li></ul></li></ul></li></ul></li><li><p><code>Security</code></p><ul><li> <code>Secure Boot</code> 设置成 <code>Disabled</code></li></ul></li><li><p><code>Boot</code></p><ul><li><p><code>Fast Boot</code> 设置成 <code>Disabled</code></p></li><li><p><code>CSM Configuration</code></p><ul><li><code>CSM Support</code> 设置成 <code>Disabled</code></li></ul></li></ul></li></ul><h3 id="5-2-安装过程"><a href="#5-2-安装过程" class="headerlink" title="[5-2] 安装过程"></a>[5-2] 安装过程</h3><p>系统安装过程大致相同，选择U盘启动后进入安装。安装过程会重启几次。</p><p>可自行搜索，参考其他人的步骤。</p><h3 id="5-3-安装时可能出现的问题"><a href="#5-3-安装时可能出现的问题" class="headerlink" title="[5-3] 安装时可能出现的问题"></a>[5-3] 安装时可能出现的问题</h3><p>显示程序副本已损坏</p><ul><li>断网</li><li>打开终端</li><li>修改时间为系统发布对应的时间。</li></ul><p>如修改为 2019年。输入 <code>date 000000002019</code>。</p><h2 id="6-DSDT，SSDT制作"><a href="#6-DSDT，SSDT制作" class="headerlink" title="[6] DSDT，SSDT制作"></a>[6] DSDT，SSDT制作</h2><p>通过修补DSDT，SSDT驱动触控板，音频，电池状态，亮度控制等。</p><h3 id="6-1-准备修补"><a href="#6-1-准备修补" class="headerlink" title="[6-1] 准备修补"></a>[6-1] 准备修补</h3><p>[6-1-1]</p><p>开机在 Clover 引导界面中按 <code>F4</code>，所需文件会加载到  <code>EFI/Clover/ACPI/origin</code> 中。通过 Clover Configurator 挂载启动的 EFI（通过U盘启动就挂载U盘）。</p><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/6-1.png" alt="6-1"></p><p>[6-1-2]</p><p>将 origin 文件夹复制到桌面，同时将 <code>iasl</code> 软件复制到文件夹中。</p><p>[6-1-3]</p><p>打开终端</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cd ~/Desktop<br>mkdir patched<br>./origin/iasl -da -dl DSDT.aml<br></code></pre></div></td></tr></table></figure><p>[6-1-4]</p><p>打开 origin，使用 <code>MaciASL</code> 打开生成的 <strong>DSDT.dsl</strong> 文件。点击 Compile，确保没有错误。（默认应该没有 error，但有很多 warning，warning 不必关系，若有 error 请将 error 处代码注释或删除）</p><p>[6-1-5]</p><p>确保没有 errors 后，点击 Patch。</p><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/6-2.png" alt="6-2"></p><h3 id="6-2-修复电池"><a href="#6-2-修复电池" class="headerlink" title="[6-2] 修复电池"></a>[6-2] 修复电池</h3><p>[1] 在弹窗的左侧点击  <code>_RehabMan Laptop/[bat]Razer Blade (2014)</code> ，等待右侧进行匹配后点击 Apply。</p><p>如果网络不好的话可能无法加载（github），请切换到合适的网络，或访问 <a href="https://github.com/RehabMan/Laptop-DSDT-Patch/blob/master/battery/battery_Razer-Blade-2014.txt">这里</a>，或复制以下代码。</p><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/6-3.png" alt="6-3"></p><figure class="highlight txt"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs txt">#Maintained by: RehabMan for: Laptop Patches<br>#battery_Razer-Blade-2014.txt<br><br># created by sidelia 2016-01-17<br># changes for Razer Blade Stealth (Kaby Lake) by BlenderSleuth (minor fixes by RehabMan)<br><br># works for:<br>#  Razer Blade (2014)<br>#  Razer Blade Stealth (Kaby Lake), per BlenderSleuth<br>#  Razer Blade (14&quot;, late 2016)<br>#  Razer Blade Pro (2017)<br>#  Razer Blade 15 (2018), per JomanJi/blodtanner<br><br>into method label B1B2 remove_entry;<br>into definitionblock code_regex . insert<br>begin<br>Method (B1B2, 2, NotSerialized) &#123; Return(Or(Arg0, ShiftLeft(Arg1, 8))) &#125;\n<br>end;<br><br>into device label EC0 code_regex BIF1,\s+16, replace_matched begin IF10,8,IF11,8, end;<br>into device label EC0 code_regex BIF2,\s+16, replace_matched begin IF20,8,IF21,8, end;<br>into device label EC0 code_regex BIF3,\s+16, replace_matched begin IF30,8,IF31,8, end;<br>into device label EC0 code_regex BIF4,\s+16, replace_matched begin IF40,8,IF41,8, end;<br><br>into device label EC0 code_regex BST0,\s+16, replace_matched begin ST00,8,ST01,8, end;<br>into device label EC0 code_regex BST1,\s+16, replace_matched begin ST10,8,ST11,8, end;<br>into device label EC0 code_regex BST2,\s+16, replace_matched begin ST20,8,ST21,8, end;<br>into device label EC0 code_regex BST3,\s+16, replace_matched begin ST30,8,ST31,8, end;<br><br>into method label _BIF code_regex \^\^EC0\.BIF1, replaceall_matched begin B1B2(^^EC0.IF10,^^EC0.IF11), end;<br>into method label _BIF code_regex \^\^EC0\.BIF2, replaceall_matched begin B1B2(^^EC0.IF20,^^EC0.IF21), end;<br>into method label _BIF code_regex \^\^EC0\.BIF3, replaceall_matched begin B1B2(^^EC0.IF30,^^EC0.IF31), end;<br>into method label _BIF code_regex \^\^EC0\.BIF4, replaceall_matched begin B1B2(^^EC0.IF40,^^EC0.IF41), end;<br><br>into method label _BST code_regex \^\^EC0\.BST0, replaceall_matched begin B1B2(^^EC0.ST00,^^EC0.ST01), end;<br>into method label _BST code_regex \^\^EC0\.BST1, replaceall_matched begin B1B2(^^EC0.ST10,^^EC0.ST11), end;<br>into method label _BST code_regex \^\^EC0\.BST2, replaceall_matched begin B1B2(^^EC0.ST20,^^EC0.ST21), end;<br>into method label _BST code_regex \^\^EC0\.BST3, replaceall_matched begin B1B2(^^EC0.ST30,^^EC0.ST31), end;<br><br># added for Razer Blade 15 (2018), per JomanJi<br>into device label EC0 code_regex BIF0,\s+16, replace_matched begin IF00,8,IF01,8, end;<br>into method label _BIF code_regex \(\^\^EC0.BIF0, replaceall_matched begin (B1B2(\^\^EC0.IF00,\^\^EC0.IF01), end;<br><br># utility methods to read/write buffers from/to EC<br>into method label RE1B parent_label EC0 remove_entry;<br>into method label RECB parent_label EC0 remove_entry;<br>into device label EC0 insert<br>begin<br>Method (RE1B, 1, NotSerialized)\n<br>&#123;\n<br>    OperationRegion(ERAM, EmbeddedControl, Arg0, 1)\n<br>    Field(ERAM, ByteAcc, NoLock, Preserve) &#123; BYTE, 8 &#125;\n<br>    Return(BYTE)\n<br>&#125;\n<br>Method (RECB, 2, Serialized)\n<br>// Arg0 - offset in bytes from zero-based EC\n<br>// Arg1 - size of buffer in bits\n<br>&#123;\n<br>    ShiftRight(Add(Arg1,7), 3, Arg1)\n<br>    Name(TEMP, Buffer(Arg1) &#123; &#125;)\n<br>    Add(Arg0, Arg1, Arg1)\n<br>    Store(0, Local0)\n<br>    While (LLess(Arg0, Arg1))\n<br>    &#123;\n<br>        Store(RE1B(Arg0), Index(TEMP, Local0))\n<br>        Increment(Arg0)\n<br>        Increment(Local0)\n<br>    &#125;\n<br>    Return(TEMP)\n<br>&#125;\n<br>end;<br><br># buffer fields<br>into device label EC0 code_regex (ECCM,)\s+(256) replace_matched begin ECCX,%2,//%1%2 end;<br>into method label _BIF code_regex \(\^\^EC0.ECCM, replaceall_matched begin (^^EC0.RECB(0x60,256), end;<br></code></pre></div></td></tr></table></figure><p>[2] 点击 Compile，确保没有错误。（默认情况下没有，不同版本BIOS可能情况不同）。</p><h3 id="6-4-修复重启保存背光亮度"><a href="#6-4-修复重启保存背光亮度" class="headerlink" title="[6-4] 修复重启保存背光亮度"></a>[6-4] 修复重启保存背光亮度</h3><p>[6-4-1]</p><p>在左侧菜单栏向下滑动，找到 <code>[gfx0] Disable/Enable on _WAK/_PTS (DSDT)</code>，点击都单击 Apply。</p><p>网络不好可点击 <a href="https://github.com/RehabMan/Laptop-DSDT-Patch/blob/master/graphics/graphics_PTS_WAK-disable.txt">这里</a> 或复制以下代码。</p><figure class="highlight txt"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs txt">  <br>#Maintained by: RehabMan for: Laptop Patches<br>#graphics_PTS_WAK-disable.txt<br><br>#<br># The purpose of this patch is to add code to to _WAK<br># that disables Radeon/nvidia on wake and add code<br># to _PTS that enables it on _PTS.<br>#<br># The path of _OFF may have to be customized to match your SSDTs<br># The patch attempts to identify the correct _REG by using<br># the ACPI PNP identifier for the EC.<br>#<br># Use this patch if you experience trouble shutting down<br># or restarting your laptop when disabling nvida/radeon.<br>#<br><br>into method label _PTS code_regex ([\s\S]*) replace_matched<br>begin<br>External(\\_SB.PCI0.PEG0.PEGP._ON, MethodObj)\n<br>If (CondRefOf(\\_SB.PCI0.PEG0.PEGP._ON)) &#123; \\_SB.PCI0.PEG0.PEGP._ON() &#125;\n<br>%1<br>end;<br><br>into method label _WAK code_regex (Return\s+\(.*) replace_matched<br>begin<br>External(\\_SB.PCI0.PEG0.PEGP._OFF, MethodObj)\n<br>If (CondRefOf(\\_SB.PCI0.PEG0.PEGP._OFF)) &#123; \\_SB.PCI0.PEG0.PEGP._OFF() &#125;\n<br>%1<br>end;<br></code></pre></div></td></tr></table></figure><p>[6-4-2] 按 command + F 搜索 <code>Device (ALSD)</code>，找到如图代码，将其替换为以下代码。</p><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/6-4.png" alt="6-4"></p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dsl">Device (_SB.ALS0)<br>&#123;<br>    Name (_HID, &quot;ACPI0008&quot;)  &#x2F;&#x2F; _HID: Hardware ID<br>    Name (_CID, &quot;smc-als&quot;)  &#x2F;&#x2F; _STA: Status<br>    Name (_ALI, 300)  &#x2F;&#x2F; _ALI: Ambient Light Illuminance<br>    Name (_ALR, Package ()  &#x2F;&#x2F; _ALR: Ambient Light Response<br>    &#123;<br>    Package () &#123; 100, 300 &#125;,<br>    &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/6-5.png" alt="6-5"></p><h3 id="6-3-修复触控板"><a href="#6-3-修复触控板" class="headerlink" title="[6-3] 修复触控板"></a>[6-3] 修复触控板</h3><p>灵刃 15 的标准版和精英版使用的触控板不同，请根据自己的电脑进行选择修复方案。</p><h4 id="6-3-1-标准版"><a href="#6-3-1-标准版" class="headerlink" title="[6-3-1] 标准版"></a>[6-3-1] 标准版</h4><p>[6-3-1-1]</p><p>继续搜索 <code>SSCN</code>。找到 Scope 为 <code>_SB.PCI0.I2C0</code> 下的 SSCN 方法。复制 SSCN 与 FMCN（在 SSCN 下方）这 两个方法。并将这两个方法如图重命名（也可选择删除）。</p><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/6-6.png" alt="6-6"></p><p>重命名为：</p><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/6-7.png" alt="6-7"></p><p>[6-3-1-3]</p><p>搜索 TPD0。将之前剪切的两个方法放到 <code>_INI</code> 方法后。</p><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/6-8.png" alt="6-8"></p><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/6-9.png" alt="6-9"></p><p>[6-3-1-4]</p><p>向下找到如下代码。</p><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/6-10.png" alt="6-10"></p><p>将其更改为如图。</p><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/6-11.png" alt="6-11"></p><h4 id="6-3-2-精英版"><a href="#6-3-2-精英版" class="headerlink" title="[6-3-2] 精英版"></a>[6-3-2] 精英版</h4><p>[6-3-2-1]  </p><p>在 Patch 页面中粘贴以下代码代码，点击 Apply。</p><p>[6-3-2-2]</p><p>点击 Compile 进行编译确定无 error（默认没有）。</p><figure class="highlight txt"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs txt">into method label _STA parent_label GPI0 replace_content begin<br>Return (0x0F)<br>end;<br><br>into_all method label _CRS parent_label TPD0 replace_content begin<br>ConcatenateResTemplate (SBFB, SBFI)<br>end;<br></code></pre></div></td></tr></table></figure><h3 id="6-4-保存修改好的-DSDT-aml"><a href="#6-4-保存修改好的-DSDT-aml" class="headerlink" title="[6-4] 保存修改好的 DSDT.aml"></a>[6-4] 保存修改好的 DSDT.aml</h3><ul><li><p>点击 File -&gt; save as 。</p></li><li><p>File Format 选择 <code>ACPI Machine Language Binary</code>。命名为 DSDT.aml。存入桌面中的 parched 文件夹中。</p></li></ul><h3 id="6-5-屏蔽-Nvdia-显卡"><a href="#6-5-屏蔽-Nvdia-显卡" class="headerlink" title="[6-5] 屏蔽 Nvdia 显卡"></a>[6-5] 屏蔽 Nvdia 显卡</h3><ul><li><strong>如果你选择安装 High Sierra 安装 WebDriver 使用 Nvidia 显卡的话，不用该补丁</strong>。</li></ul><p><a href="%5Bhttps%5D(https://www.tonymacx86.com/nvidia-drivers/">点击这里查看支持驱动的 High Sierra </a> : <a href="https://www.tonymacx86.com/nvidia-drivers/">//www.tonymacx86.com/nvidia-drivers/</a>)</p><ul><li><strong>在的笔记本上使用该补丁会导致 type-c 转视频接口无信号，无法拓展显示器，若出现相同情况请删除该补丁。</strong></li></ul><p>[6-5-1]</p><p>再次进入 origin 文件夹中，在终端输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./origin/iasl -da -dl SSDT-12-OptTabl.aml<br></code></pre></div></td></tr></table></figure><p>[6-5-2]</p><p>根据上方修补电池状态，触控板的方式类似，使用 MaciASL 打开 <strong>SSDT-12-OptTabl.dsl</strong></p><p>[6-5-3]</p><p> 按 command + F 搜索以下代码</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">Method (_OFF, 0, Serialized)  // _OFF: Power Off<br></code></pre></div></td></tr></table></figure><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/6-12.png" alt="6-12"></p><p>[6-5-4]</p><p> 在该代码上方，粘贴以下代码</p><figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dsl">Method (_INI) &#123;_OFF() &#125; &#x2F;&#x2F; added to call _OFF<br></code></pre></div></td></tr></table></figure><p>[6-5-5]</p><p>点击 patch，将以下代码粘贴到弹窗中，点击 apply。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">into method label _INI parent_label \_SB.PCI0.GFX0 insert<br>begin<br>//added to turn nvidia/radeon off\n<br>External(\_SB.PCI0.PEG0.PEGP._OFF, MethodObj)\n<br>\n<br>end;<br></code></pre></div></td></tr></table></figure><p>[6-5-6]</p><p>点击编译，出现一个错误。</p><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/6-13.png" alt="6-13"></p><p>[6-5-7]</p><p>搜索一下代码，并将其删除，再次编译。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">External (_SB_.PCI0.PEG0.TGPC, IntObj)    // (from opcode)<br></code></pre></div></td></tr></table></figure><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/6-14.png" alt="6-10"></p><p>[6-5-8]</p><p>点击 File -&gt; Save As。将最终的 /aml 文件保存。</p><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/6-15.png" alt="6-11"></p><h3 id="6-6-制作-SSDT-USBX-aml"><a href="#6-6-制作-SSDT-USBX-aml" class="headerlink" title="[6-6] 制作 SSDT-USBX.aml"></a>[6-6] 制作 SSDT-USBX.aml</h3><p>如果想制作自己的 SSDT-USBX.aml。请参考 <a href="https://github.com/stonevil/Razer_Blade_Advanced_early_2019_Hackintosh#usb-mapping">点我。</a></p><p>使用 USBMap。<a href="https://github.com/corpnewt/USBMap">点我</a></p><h3 id="6-7-复制提供的的-aml-文件"><a href="#6-7-复制提供的的-aml-文件" class="headerlink" title="[6-7] 复制提供的的 .aml 文件"></a>[6-7] 复制提供的的 .aml 文件</h3><p>将文件夹中的 SSDT-PNLF.aml，SSDT-UIAC-ALL.aml，SSDT-USBX.aml，SSDT-XOSI.aml 同上面修补的两个文件一同放入 patched 文件夹中，最后 patched 文件夹中应该有如下6个文件。</p><p><strong>如果 type-c 转视频接口无信号，请删除SSDT-12-OptTabl.aml</strong></p><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/6-16.png" alt="6-16"></p><h2 id="7-网卡"><a href="#7-网卡" class="headerlink" title="[7] 网卡"></a>[7] 网卡</h2><h3 id="7-1-更换博通网卡"><a href="#7-1-更换博通网卡" class="headerlink" title="[7-1] 更换博通网卡"></a>[7-1] 更换博通网卡</h3><p>在网上找过拆机图，网卡附近的位置还是挺多的，我的选择是拆机的 <code>BCM94360cs2</code> + 转接卡，可直接免驱使用。</p><p>相比使用原装的网卡位置稍有点高，压在一根的排线上，但是不影响，如选择同款网卡，请注意绝缘，建议上螺丝的时候不要拧太紧，不松动即可。装上之后的效果如图。</p><p><strong>小提示：</strong>拧螺丝前最好把易碎贴给清理干净。这个贴纸分量太足，卡在螺丝孔中导致一直滑丝。</p><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/7-1.png" alt="7-1"></p><p><strong>使用效果：</strong>2.4G WIFI 和 蓝牙有干扰，尤其是 2.4G WIFI 使用带宽高的时候，蓝牙几乎不能用。其他使用场景基本良好。</p><ul><li><p>想折腾的话可选择 <code>DW1820A</code>，可参考 <a href="https://blog.daliansky.net/DW1820A_BCM94350ZAE-driver-inserts-the-correct-posture.html">这里。</a></p></li><li><p>博通 <code>BCM94352Z</code> ，现在价钱被炒的很高，目前将近 300，有钱随意。</p></li></ul><h3 id="7-2-使用自带网卡"><a href="#7-2-使用自带网卡" class="headerlink" title="[7-2] 使用自带网卡"></a>[7-2] 使用自带网卡</h3><p>Intel 蓝牙默认免驱，WiFi 目前无解。</p><p>蓝牙从 windows 重启进入 macOS 可使用（网卡未断电所以上传了驱动）。</p><p>将 <a href="https://github.com/zxystd/IntelBluetoothFirmware/releases">该驱动</a> 放入 EFI/CLOVER/kexts，可以实现冷启动驱动自带网卡蓝牙。</p><p><strong>使用效果：</strong>蓝牙键盘，蓝牙音箱没有问题，蓝牙鼠标貌似不能用。</p><h3 id="7-3-使用USB网卡"><a href="#7-3-使用USB网卡" class="headerlink" title="[7-3] 使用USB网卡"></a>[7-3] 使用USB网卡</h3><p>usb 网卡驱动安装。<a href="https://github.com/chris1111/Wireless-USB-Adapter-Clover/releases">点我。</a></p><ul><li>COMFAST  CF-WU815N  150M 单频</li><li>COMFAST  CF-811AC  650M 双频</li><li>COMFAST  CF-812AC  1300M 双频</li><li>更多其他型号自行搜索</li></ul><h2 id="8-一些优化"><a href="#8-一些优化" class="headerlink" title="[8] 一些优化"></a>[8] 一些优化</h2><h3 id="8-1-HIDPI"><a href="#8-1-HIDPI" class="headerlink" title="[8-1] HIDPI"></a>[8-1] HIDPI</h3><p>开启 HIDPI 后可能会导致开机第二阶段 Logo 变大，因为分辨率是仿冒的，不影响使用。</p><p>使用终端执行：</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/xzhih/one-key-hidpi/master/hidpi.sh)</span>&quot;</span><br></code></pre></div></td></tr></table></figure><ul><li><p>选择 “开启 HIDPI”</p></li><li><p>显示的 ICON 选择 Macbook Pro（在设置界面显示的样式）</p></li><li><p>选择分辨率配置 1080P 显示器（根据自身情况选择）</p></li></ul><p>更多详细情况可参考这篇文章。<a href="https://www.sqlsec.com/2018/09/hidpi.html">点我。</a></p><h3 id="8-2-打开-TRIM"><a href="#8-2-打开-TRIM" class="headerlink" title="[8-2] 打开 TRIM"></a>[8-2] 打开 TRIM</h3><p>如果使用 SSD，一定要打开 TRIM，防止系统多次擦写，确保硬盘寿命。</p><figure class="highlight zsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">sudo trimforce <span class="hljs-built_in">enable</span><br></code></pre></div></td></tr></table></figure><p>完成后系统会进行一次重启。</p><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/8-1.png" alt="8-1"></p><h3 id="8-3-禁用睡眠"><a href="#8-3-禁用睡眠" class="headerlink" title="[8-3] 禁用睡眠"></a>[8-3] 禁用睡眠</h3><p>在终端运行以下命令，并在 设置 -&gt; 节能 中关闭相应设置。 </p><figure class="highlight zsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs zsh">sudo pmset -a hibernatemode 0<br><br>sudo rm /var/vm/sleepimage<br><br>sudo mkdir /var/vm/sleepimage<br></code></pre></div></td></tr></table></figure><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/8-2.png" alt="8-2"></p><p><img src="https://source.letitout.cloud/images/articles/2020/02/razer-blade-base-hackintosh/8-3.png" alt="8-3"></p><h3 id="8-4-“洗白”序列号"><a href="#8-4-“洗白”序列号" class="headerlink" title="[8-4] “洗白”序列号"></a>[8-4] “洗白”序列号</h3><p>网络上已经有很多教程，自行搜一下。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/stonevil/Razer_Blade_Advanced_early_2019_Hackintosh">https://github.com/stonevil/Razer_Blade_Advanced_early_2019_Hackintosh</a></li><li><a href="https://www.tonymacx86.com/threads/guide-razer-blade-15-2018-detailed-install-guide-high-sierra-10-13-6-17g2208-17g5019.264017/">https://www.tonymacx86.com/threads/guide-razer-blade-15-2018-detailed-install-guide-high-sierra-10-13-6-17g2208-17g5019.264017/</a></li><li><a href="https://blog.daliansky.net/">https://blog.daliansky.net/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Hackintosh</category>
      
    </categories>
    
    
    <tags>
      
      <tag>黑苹果</tag>
      
      <tag>Hackintosh</tag>
      
      <tag>系统安装</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
